<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<title>Sauerbraten Mapping Command Reference</title>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
<h1>Editing Related Console Commands</h1>

<p style="text-align: center;">
<a href="#editing">Editing</a>
<a href="#heightfield">Heightfield</a>
<a href="#entity">Entity</a>
<a href="#settings">Settings</a>
<a href="#map">Map and Config</a>
<a href="#lightingcommands">Lighting</a>
<a href="#entitytypes">Entity Types</a>
<a href="#hud">The HUD</a>
</p>

<a name="editing"></a><h1>Editing</h1>

<pre>edittoggle</pre>
<p>
Switches between map edit mode and normal (default key: e). In map edit mode
you can select bits of the map by clicking or dragging your crosshair on the
cubes (using the "attack" command, normally MOUSE1), then use the commands
below to modify the selection. While in edit mode, physics &amp; collision
don't apply (noclip), and key repeat is ON.
</p>

<pre>dragging 0/1</pre>
<p>
Select cubes when set to 1. stop selection when set to 0
</p>

<pre>editdrag</pre>
<p>
Select cubes and entities. (default: left mouse button)
</p>

<pre>selcorners</pre>
<p>
Select the corners of cubes. (default: middle mouse button)
</p>

<pre>moving 0/1</pre>
<p>
set to 1 to turn on. when on, it will move the selection (cubes not included) to another position. 
the plane on which it will move on is dependent on which side of the selection your cursor was on when 
turned on. set to 0 to turn off moving. if cursor is not on selection when turned on, moving
will automatically be turned off.
</p>

<pre>editmovedrag</pre>
<p>
if cursor is in current cube selection, holding will move selection. otherwise will create new selection.
</p>

<pre>cancelsel</pre>
<p>
Cancels out any explicit selection you currently have (default: space).
</p>

<pre>editface D N</pre>
<p>
This is the main editing command. D is the direction of the action, -1 for
towards you, 1 for away from you. N=0 to push all corners in the white box. N=1
create or destroy cubes. N=2 push or pull a corner you are pointing at.       
</p>

<pre>gridpower N</pre>
<p>
Changes the size of the grid. (default: g + scrollwheel)
</p>

<pre>edittex D</pre>
<p>
Changes the texture on current selection by browsing through a list of textures
directly shown on the cubes. D is the direction you want to cycle the textures
in (1 = forwards, -1 = backwards) (default: y + scrollwheel).
The way this works is slightly strange at first, but allows for very fast
texture assignment. All textures are in a list. and each time a texture is
used, it is moved to the top of the list. So after a bit of editing, all your
most frequently used textures will come first, and the most recently used
texture is set immediately when you press the forward key for the type. These
lists are saved with the map.
</p>

<pre>gettex</pre>
<p>
moves the texture on the current selection to the top of the texture list. Useful for quickly
texturing things using already textured geometry.
</p>

<pre>selextend</pre>
<p>
Extend current selection to include the cursor.
</p>

<pre>passthrough</pre>
<p>
normally cubes of equal size to the grid are given priority when selecting.
passthrough removes this priority while held down so that the cube the cursor is directly on is selected.   
Holding down passthrough will also give priority to cube over entities. (default: alt)
</p>

<pre>reorient</pre>
<p>
Change the side the white box is on to be the same as where you are currently
pointing. (default: shift)
</p>

<pre>flip</pre>
<p>
Flip (mirror) the selected cubes front to back relative to the side of the
white box. (default: x)
</p>

<pre>rotate D</pre>
<p>
Rotates the selection 90 degrees around the side of the white box.
Automatically squares the selection if it isn't already.
(default: r + scroll wheel)
</p>

<pre>undo</pre>
<p>
Multi-level undo of any of the changes caused by the above operations (default: z [or u]).
</p>

<pre>redo</pre>
<p>
Multi-level redo of any of the changes caused by the above undo (default: i).      
</p>

<pre>
copy
paste
</pre>
<p>
Copy copies the current selection into a buffer. For pasting, if the current
selection is not the same size as the copy, the corner of the red reference box
will be used as the origin. If the current gridsize is changed from the copy,
the pasted copy will be stretched by the same factor.

Copy will work on entities as well as cubes. However it does not work on both at the same time. 
So if you select a set of cubes, the entities within that selection will not
be copied over on a paste. (default: c and v respectively)
</p>

<pre>replace</pre>
<p>
Repeats the last texture edit across the whole map. Only those faces with
textures matching the one that was last edited will be
replaced.        
</p>

<pre>editmat</pre>
<p>
Changes the type of material left behind when a cube is deleted. Currently the
following types of materials are supported:
<ul>
<li>
air: the default material, has no effect.
<li>
water: acts as you would expect. Only renders from the top, so treat it like
real water and keep all 4 sides contained. Shows blue volume in edit mode.
<li>
clip: an invisible wall that blocks players movement but not bullets. Is
ideally used to keep players "in bounds" in a map. Can be used sparingly to
smooth out the flow around decoration. Shows red volume in edit mode.
<li>
noclip: cubes are always treated as empty in physics. Shows green volume in edit mode.
<li>
glass: a clip-like material with a blended/reflective surface. Glass also stops bullets.
Will reflect the closest envmap entity, or if none is in range, the skybox.
Shows cyan volume in edit mode.
</ul>
</p>

<pre>recalc</pre>
<p>
Recalculates scene geometry. Shouldn't be needed under normal curcumstances.
</p>

<a name="heightfield"></a>        
<h1>Heightfield</h1>

<pre>getheightmap</pre>
<p>
This command will turn any selection into a heightmap mode selection (default: H). When this
happens the selection will turn green with the orientation and gridsize denoted
by four corner squares on one side of the selection. When the selection enters heightmap
mode, the cubes within the selection will mimic a heightmap and so the geometry within
the selection will be changed if it is not already of heightmap style.

The point of heightmap mode is that all editface commands will now edit
the selected cubes using a brush instead of the default behaviour. The selection will
also dynamically resize itself in order to generate the entire heightmap. This obviously
means that it can overwrite cubes below and above it. Other then these changes
the selection functions exactly the same as the normal selection, which means you can copy it,
extend it, cancel it, etc. The only exceptions to this right now are the flip and
rotate commands. This type of selection cannot currently be used in coop edit.
</p>

<pre>selectbrush D</pre>
<p>
This is not an actual engine command, but rather an alias which is defined
in data/brush.cfg. It is to be used as a modifier (default: B), and switches between the
various brushes that have been saved within that config file.
</p>

<pre>copybrush</pre>
<p>
This command (default: K) copies the current heightmap mode selection and
saves it as a new brush. The current location of the cursor will turn into the
new handle of the brush.
</p>

<pre>savebrush name</pre>
<p>
This will save the current brush in script format. This script will be saved in 
a file called mybrushes.cfg file for example. This is usually used after copybrush.
The brush can also be named for easy reference later.
</p>

<pre>clearbrush</pre>
<p>
This resets the current brush that is used during heightmap mode editing.
</p>

<pre>brushvert x y depth </pre>
<p>
A brush is a 2D map that describes the depth that the editface commands should
push into the cubes at various points. The first two parameters of brushvert are the X and Y
coordinates, respectively, of a vert on this 2D map. The last parameter
is used to set the depth.
</p>

<pre>
brushx
brushy
</pre>
<p>
Along with the 2D map, all brushes also have a handle. This handle is a reference
point on the 2D map which defines where the brush is relative to the editing cursor.
These two variables define the brush handle's coordinates.

<a name="entity"></a>        
<h1>Entity</h1>
</p>

<pre>newent type    value1 value2 value3 value4</pre>
<p>
Adds a new entity where (x,y) is determined by the current selection (the red
dot corner) and z by the camera height, of said type. Type is a string giving
the type of entity, such as "light", and may optionally take values (depending
on the entity). The types are defines below in the <a href="#entitytypes">Entity
Types</a> section.
</p>

<pre>delent</pre>
<p>
deletes the selected entities
</p>

<pre>entflip</pre>
<p>
flip the selected entities. cube selection serves as both reference point and 
orientation to flip around.
</p>

<pre>entpush D</pre>
<p>
push the selected entities. cube selection serves as orientation to push towards.
</p>

<pre>entrotate D</pre>
<p>
rotate the selected entities. cube selection serves as both reference point and 
orientation to rotate around.
</p>

<pre>entmoving 0/1</pre>
<p>
set to 1 to turn on. if an entity is under the cursor when turned on, the
entity will get toggled selected/unselected. if selected, one can move the
entity around using the cursor. if multiple entities are selected, they will 
also move. the plane on which the entity will be moved is
dependent on the orientation of the cube selection. set to 0 to turn off moving.
if no entity is under the cursor when turned on, it will automatically turn off.
</p>


<pre>entdrop N</pre>
<p>
variable controlling where entities created with "newent" will be placed.
N=0 place entities at your current eye position.
N=1 drop entities to the floor beneath you. Lights, however, will be placed at
your current eye position as for N=0.
N=2 place entities at the center of the currently selected cube face. If a
corner is selected, the entity will be placed at the corner vertex.
N=3 behaves as with N=2, except all entities, including lights, will then
bedropped from that position to whatever floor lies beneath. This mode is
useful for placing objects on selected floors. Lights are also dropped to the
floor, unlike for N=1.
</p>

<pre>dropent</pre>
<p>
Positions the selected entity according to the entdrop variable.
</p>

<pre>trigger T N</pre>
<p>
Sets the state of all locked triggers with tag T to N.
</p>

<pre>entselect X</pre>
<p>
Takes a boolean expression as argument. Selects all entities that evaluate to true for the given expression.<br>
examples:<br>
entselect insel // select all entities in blue selection box<br>
entselect [ strcmp (et) "shells" ] // select all shells in map
</p>

<pre>entcancel</pre>
<p>
deselect all entities
</p>

<pre>enthavesel</pre>
<p>
Returns the number of entities in the current selection.
</p>

<pre>insel</pre>
<p>
Returns true if the selected entity is inside the cube selection
</p>

<pre>et</pre>
<p>
Returns a string for scripts that has the 'type' of the selected entity.
</p>

<pre>ea N</pre>
<p>
Returns a string for scripts that has the 'attribute' of the selected entity. Attributes are numbered 0 to 3.

<pre>entedit type    value1 value2 value3 value4</pre>
<p>
Change the type and attributes of the selected entity.
To quickly bring up the entedit command in the console press '.' (default: period). It will come pre-filled with the values of the current entity selection.
</p>

<pre>entproperty P A</pre>
<p>
Changes property P (0..3) of the closest entity by amount A. For example
"entproperty 0 2" when executed near a lightsource would increase its radius by
2.
</p>

<pre>entfind type</pre>
<p>
Select all entities of said type.
</p>

<pre>clearents type</pre>
<p>
Deletes all entities of said type.
</p>

<pre>replaceents type value1 value2 value3 value4</pre>
<p>
Replaces the given values for the selected entity and all entities that are
equal to the selected entity. 
To quickly bring up the replaceents command in the console press ',' (default: comma). It will come pre-filled with the values of the current entity selection.
</p>

<a name="settings"></a>        
<h1>Settings</h1>
</p>

<pre>undomegs N</pre>
<p>
Sets the number of megabytes used for the undo buffer (default 5, max 100).
Undo's work for any size areas, so the amount of undo steps per megabyte is
more for small areas than for big ones.
</p>

<pre>showsky B</pre>
<p>
This variable controls whether explicit sky polygons are outlined (in purple) in edit mode.
Default = 1.
</p>

<pre>outline B</pre>
<p>
This variable controls whether geometry boundaries (outlines) are shown.
Default = 0.
</p>

<pre>wireframe 0/1</pre>
<p>
Turns on wireframe drawing of the map.
</p>

<pre>allfaces 0/1</pre>
<p>
when on, causes the texturing commands to apply the new texture to all sides of the selected cubes
rather than just the selected face.
</p>

<pre>showmat B</pre>
<p>
This variables whether volumes are shown for invisible material surfaces in edit mode.
Material volumes may also be selected while this is enabled. Default = 1.
</p>

<pre>optmats B</pre>
<p>
This variables controls whether material rendering should be optimized by grouping materials
into the largest possible surfaces. This will always make rendering faster, so the only reason
to disable it is for testing. Default = 1.
</p>

<pre>entselradius N</pre>
<p>
Sets the 'handle' size of entities when trying to select them. 
Larger sizes means it should be easier to select entities.
</p>

<pre>entselsnap 0/1</pre>
<p>
Turns on snap-to-grid while draggin entities. (default: 6)

<a name="map"></a>        
<h1>Map and Config</h1>
</p>

<pre>map name</pre>
<p>
Loads up map "name" in the gamemode set previously by "mode". A map given as
"blah" refers to "packages/base/blah.cgz", "mypackage/blah" refers to
"packages/mypackage/blah.cgz". The menu has a set of maps that can be loaded.
See also map in the gameplay docs.

At every map load, "data/default_map_settings.cfg" is loaded which sets up all
texture definitions etc. Everything defined in there can be overridden per
package or per map by creating a "package.cfg" or "mapname.cfg" which contains
whatever you want to do differently from the default. It can also set up
triggers scripts per map etc.

When the map finishes it will load the next map when one is defined, otherwise
reloads the current map. You can define what map follows a particular map by
making an alias like (in the map script): <code>alias nextmap_blah1 blah2</code>
(loads "blah2" after "blah1").
</p>

<pre>sendmap</pre>
<p>
Saves the current map (without lightmaps) and sends it to the server so other clients may download it.
Only works in coopedit game mode.
</p>

<pre>getmap</pre>
<p>
Gets a map from the server if one is available. Automatically loads the map when done. Only works in coopedit
game mode.        
</p>

<pre>savemap name
savecurrentmap</pre>
<p>
Saves the current map, using the same naming scheme as "map". Makes a versioned
backup to "mapname_N.BAK" if a map by that name already exists, so you can never
lose a map. With "savemap", if you leave out the "name" argument, it is saved under the current map name.
With "savecurrentmap", the map is saved with the name determined by the current game.

Where you store a map depends on the complexity of what you are creating: if
its a single map (maybe with its own .cfg) then the "base" package is the best
place. If its multiple maps or a map with new media (textures etc.) its better
to store it in its own package (a directory under "packages"), which makes
distributing it less messy.
</p>

<pre>newmap size</pre>
<p>
Creates a new map of size^2 cubes (on the smallest grid size). 10 is a small
map, 15 is a large map but it goes up to 20.
</p>

<pre>mapenlarge</pre>
<p>
Doubles the dimensions of the current map.        
</p>

<pre>mapmsg "Title by Author"</pre>
<p>
sets the map msg, which will be displayed when the map loads. Either use the
above format, or simply "by Author" if the map has no particular title (always
displayed after the map load msg).
</p>

<pre>texturereset</pre>
<p>
Sets the texture slot to 0 for the subsequent "texture" commands.
</p>

<pre>materialreset</pre>
<p>
Resets the material texture slots for subsequent "texture" commands.
</p>

<pre>texture TYPE FILENAME ROT X Y</pre>
<p>
Binds the texture indicated in FILENAME to the current texture slot, then
increments the slot number depending on TYPE. This is for use in texture.cfg files only. TYPE
allows secondary textures to be specified for a single texture slot, for use in
shaders and other features: 0 or "c" for primary diffuse texture (RGB), 1 or "u" for generic secondary texture, "d" for decals (RGBA), "n" for normal maps (XYZ), "g" for glow maps (RGB), "s" for specularity maps (grey-scale), "z" for depth maps (Z). 
Specifying the primary diffuse texture advances to the next texture slot as above, while secondary types fill additional texture units in the order specified in the .cfg file. Normal ("n") and glow ("g") maps will automatically be combined with specularity ("s") and depth ("z") maps, filling the unused A component, into one texture. Decal ("d") and glow ("g") maps will be blended into the diffuse texture if running without shaders. To disable this combining, specify secondary textures as generic with 1 or "u". TYPE may also be a material name, in which case it behaves like 0, but instead associates the slot with a material.
ROT specifies preprocessing on the image, currently only rotation and flipping (0 = none, 1 = 90 CW, 2 = 180, 3 = 270 CW, 4 = X flip, 5 = Y flip). X and Y are the X and Y offset in texels.

<p>
</p>

<pre>fog N</pre>
<p>
Sets fog distance to N (default: 160). You can do this for tweaking the visual effect of the fog, or if you are on a slow machine,
setting the fog to a low value can also be a very effective way to increase fps (if you are geometry limited). Try out different
values on big maps or maps which give you low fps.
</p>

<p>
</p>

<pre>fogcolour N</pre>
<p>
The colour of the fog, which may be represetned as a decimal integer from 0..16777215, or a hexidecimal value from 0x000000..0xFFFFFF
(note the "0x") in "0xRRGGBB" format, where R is red, G is green, and B is blue values (default: 8427955 (0x8099B3)).
</p>

<pre>waterspec N</pre>
<p>
This sets the percentage of light water shows as specularity (default: 150).
</p>

<pre>waterfog N</pre>
<p>
Sets the distance beneath the surface of water at which it fogs, from 1..10000 (default: 150).
</p>

<p>
</p>

<pre>watercolour R G B</pre>
<p>
Sets the the colour of fog inside the water to the specified R G B value from 0..255 (default: 20 80 80). Used to give water some colour.
</p>

</p>

<pre>shader TYPE NAME VS PS</pre>
<p>
defines a shader NAME with vertex shader VS and pixel shader PS (both in ARB OpenGL 1.5 assembly format). See data/stdshader.cfg for examples.
These definitions can be put in map cfg files or anywhere else, and will only be compiled once.
TYPE indicates what resources the shader provides, or what backup method should be used if the graphics card does not support shaders.
TYPE is either 0 for default shader, 1 for decal shader, 2 for bumpmapped shader, or 3 for bumpmapped shader with glowmap.
Requires DX9 / shader 2 class hardware (radeon 9500 or better, geforce 5200 or better) to run (older hardware will default to basic rendering).
</p>

<pre>setshader NAME</pre>
<p>
Sets a previously defined shader as the current shader. Any following texture slots (see "texture" command) will have this shader
attached to it.
</p>

<pre>fastshader NICE FAST N</pre>
<p>
Associates shader FAST so that it will run in place of shader NICE if shaderdetail is less than or equal to N.
</p>

<pre>music name
music name ondone</pre>
<p>
Plays song "name" (with "packages" as base dir). This command is best used from
map cfg files or triggers. Evaluates ondone when the song is finished, or just keeps
looping the song if ondone is missing. Example:

<code>music "songs/music.ogg" [ echo "Song dong playing!" ]</code>
</p>

<pre>N = registersound name V</pre>
<p>
Registers sound "name" with cube (see for example data/sounds.cfg). This
command returns the sound number N, which is assigned from 0 onwards, and which
can be used with "sound" command below. if the sound was already registered,
its existing index is returned. registersound does not actually load the sound,
this is done on first play. V is volume adjustment, if not specified (0), it is the default 100, valid
range is 1-255.</p>

<pre>sound N</pre>
<p>
Plays sound N, see data/sounds.cfg for default sounds, and use registersound to
register your own. for example, <code>sound 0</code> and <code>sound (registersound
"aard/jump")</code>both play the standard jump sound.
</p>

<pre>mapmodel R H T N SH</pre>
<p>
Registers a mapmodel that can be placed in maps using <code><font size="2">newent
mapmodel</font></code> (see newent). N is the name, R is the square
radius, H the height, T the texture slot to skin the model with (0 for default skin), and SH toggles whether the it
will cast shadows (not given or 1 casts shadows, 0 has no shadows). The radius R and height
H define the collision bounding box of the model (if either is 0, players won't collide
with the mapmodel). Name N is the name of a folder inside packages/models folder, e.g.
"hudguns/rifle". Loaded from that folder are: tris.md2 and skin.jpg (and if not available,
skin.png, or the same from the parent folder to allow skin sharing).


Example: <code><font size="2">mapmodel 4 32 0 "tree1"</font></code>

This map model is loaded from packages/models/tree1/. It has a collision box 8x8x32 in size (x=2*R, y=2*R, z=H). It uses the model's default skin (texture slot=0).
It casts shadows (default).
</p>

<pre>importcube N</pre>
<p>
Imports a cube map (.cgz) and converts it to sauerbraten's map format. N is the
name of the map, without the .cgz. The map file must reside in packages/cube,
which is because that folder has a package.cfg that sets the default cube
textures. If the cube map in question has a custom texture list, it will have
to be adapted manually. Currently converts everything relatively faithfully,
except heighfields which are converted as best as possible but not always
accurately. Slopes tend to work faultlessly, landscape style stuff is usuable,
but curves/arches are problematic, and may have to be redone. All entities are
converted though mapmodels may not be present, and light entities are useless
because of their 2d nature, so probably the first thing to do after converting
a map is /clearents light, and place some new lights. Pickups and other items
may spawn inside the walls because they have no proper Z value, you may have to
correct these manually. The importcube command does not automatically save the
map, you still have to do a /savecurrentmap which will create
packages/cube/N.ogz. Reload the map to be able to pick up stuff. Waterlevel is
also not supported, you will have to add water using the new material system.
</p>

<pre>lodsize N</pre>
<p>
Turn on world LOD (level of detail) for this map if N=32 (default is N=0, off).
The state of this command is saved with the map. N is the size of the blocks
that will be used for LOD, in theory you can use 16 or 64 as well, but this
usually just either just hurts performance, memory usage or visual quality. Use
32 unless you know exactly what you are doing. After setting this var, LOD will
only become apparent after a "recalc" (and "calclight") command. Turning LOD on
for a map is only useful on really large maps with lots of detail where you can
see for half a mile, on smaller maps it will have no effect and only wastes
memory / lightmap space. LOD works on entire vertex array blocks at a time, and
is dependent on the "loddistance" variable which the player can set to trade
off speed vs visual quality.
</p>

<pre>writeobj N</pre>
<p>
Writes out the current map as N.obj, so you could use sauerbraten as a generic modeller
with any program/engine that uses meshes. The meshes aren't very optimal and don't
have texture/lighting information.



<a name="lightingcommands"></a>        
<h1>Lighting</h1>
</p>

<pre>calclight Q</pre>
<p>
This calculates all lightmaps. Usually takes only a few seconds, depending on
map size and settings. If you "savemap", the lightmap will be stored along with
it. Q is these predefined quality settinsg:
<ul>
<li>2: 8x anti aliasing, shadows for mapmodels also (maximum quality, very slow)</li>
<li>1: 8x anti aliasing, world shadows only (better lighting quality for huge maps, slow)</li>
<li>0: 4x anti aliasing, world shadows only (default, good enough for most maps)</li>
<li>-1: no anti aliasing, but still shadowed (good for shadow previews)</li>
<li>-2: no anti aliasing and no shadows (VERY fast, good for lighting previews)</li>
</ul>
</p>

<pre>patchlight</pre>
<p>
This will calculate lightmaps for any newly created cubes. This will generally
be much quicker than doing a "calclight", and so is very useful when editing.
However, it will make very inefficient use of lightmap textures, and any new
cubes will not properly cast shadows on surfaces that are already lit. It is
recommended you do a "calclight" on your map before you publish it with
"savemap".
</p>

<pre>fullbright B</pre>
<p>
This variable controls whether the map will be shown with lighting disabled.
Fullbright 1 will disable lighting, whereas 0 will enable lighting. (Default =
0)
</p>

<pre>lerpangle A</pre>
<p>
Default = 44. This variable controls whether surface normals are interpolated for
lighting. Normals are sampled at each vertex of the surface. If the angle between
two surfaces' normals (which meet at a vertex) is less than A, then the resulting
normal will be the average of the two. Normals are then later interpolated between
the normals at the vertexes of a surface.
</p>

<pre>lerpsubdiv N</pre>
<p>
Default = 2. This allows more normals to be sampled at points along an edge between
two vertexes of a surface. 2^N-1 extra normals will be sampled along the edge, i.e.
the edge is split in half for every increment of N.
</p>

<pre>lerpsubdivsize N</pre>
<p>
Default = 4. This sets the minimum size to which an edge may be subdivided. Edges
smaller than N or edge sections smaller than N will not be sampled.
</p>

<pre>lightprecision P</pre>
<p>
Default = 32. This is the most important variable for tweaking the lighting, it
determines what the resolution of the lightmap is. As such has a BIG effect on
calculation time, video memory usage, and map file size. The default is good
for most maps, you may go as low as 16 if you are lighting a really small map
and love hard shadows, and for bigger maps you may need to set it to 64 or so
to get reasonable memory usage.


The number to watch out for is the number of lightmaps generated which are
shown on the HUD (and also as output after a calclight). 1 or 2 lightmap
textures is very good, over 10 lightmap textures is excessive.


The map file size is for 90% determined by the lightmaps, so tweak this value
to get an acceptable quality to size ratio. Look at the size of the map files,
sometimes a slightly higher lightprecision can halve the size of your .ogz.


Every surface matters, even though sauerbraten attempts to compress surfaces
with a uniform lightvalue, it is always a good ideas to delete parts of the
world that are not part of your map. Lightprecision, lighterror, and lightlod
are stored as part of map files.
</p>

<pre>lighterror E</pre>
<p>
There should be little reason to tweak this. If in your map you can see visible
polygon boundaries caused by lighting, you can try stepping this down to 6 or 4
to improve quality at the expense of lightmap space. If you have an insanely
large map and looking for ways to reduce file size, increasing error up to 16
may help. (Default = 8)
</p>

<pre>lightlod D</pre>
<p>
Default = 0. This will double the resolution of lightmaps (cut the
lightprecision in half) if size of the surface being lit is smaller than 2^D
units. This allows large maps to have pockets of detailed lighting without
using a high resolution over everything.


NOTE: if you feel like using this, test it thoroughly. On medium or small sized
detailed maps, this command wastes space, use lightlod 0. Lightlod &gt; 0 is
only useful for huge maps
</p>

<pre>dumplms</pre>
<p>
Dumps all lightmaps to a set of .bmps. Mostly interesting for developers, but
mappers may find it interesting too.

<a name="entitytypes"></a>        
<h1>Entity Types</h1>
</p>

<pre>"light" radius r g b</pre>
<p>
If G and B are 0 the R value will be taken as brightness for a white light. A
good radius for a small wall light is 64, for a middle sized room 128... for a
sun probably more like 1000. Lights with a radius of 0 do not attenuate and may
be more appropriate for simulating sunlight or ambient light; however, this
comes at the cost of slightly greater map file sizes. See the <a href="#lightingcommands">
lighting commands</a> for an indepth list of all lighting related commands.
</p>

<pre>"envmap"
"envmap" radius</pre>
Creates an environment map reflecting the geometry around the entity. The optional radius
overrides the maximum distance within which glass will reflect from this environment map. If none is specified,
the default is taken from the variable "envmapradius" (which defaults to 128 units), which may also be set in 
map cfgs. Environment maps are generated on a map load, or can be regenerated while editing using the "recalc" command.

Please use the absolute minimum number of these possible. Each one uses up a decent amount of texture memory. 
For instance, rather than using two environment maps on each side of a window, use only one in the middle of the pane
of glass. If you have a wall with many windows, place only one environment map in the middle of the wall geometry, and 
it should work just fine for all the windows.

<pre>"playerstart"</pre>
<p>
Spawn spot, yaw is taken from the current camera yaw.
</p>

<pre>"shells"
"bullets"
"rockets"
"riflerounds"
"grenades"
"cartridges"
"health"
"healthboost"
"greenarmour"
"yellowarmour"
"quaddamage"</pre>
<p>
A variety of pickup-able items, see <a href="./game.html">here</a>.
</p>

<pre>"teleport" N
"teledest" N</pre>
<p>
creates a teleport connection, teleports are linked to a teledest with the same
N (of which there should be exactly one). N can be 0..255. The teledest uses
the current camera yaw.
</p>

<pre>"mapmodel" N Type Trigger</pre>
<p>
A map model, i.e. an object rendered as md2/md3 which you collide against, cast
shadows etc. N determines which mapmodel you want, this depends on "mapmodel" declarations
in the maps cfg file. Yaw of the model is taken from the current camera yaw. Type
specifies mapmodel behaviour such as triggers, see table below. Trigger is the trigger
number, 0 means no trigger. This number specifies what trigger to activate, and in addition, 
the alias "<span style="font-family: Courier New">level_trigger_Trigger</span>"
will be executed, where Trigger is substituted accordingly (this allows you to script
additional actions upon a trigger, i.e. put this into your map cfg file to print
a message: <span style="font-family: Courier New">alias level_trigger_1 "echo A door
opened nearby"</span>). The alias "<span style="font-family: Courier New">triggerstate</span>" will hold a value of -1, 0, or 1 indicating how the trigger was activated.<br />
<br />
<table border="1" cellpadding="2" cellspacing="0" style="font-size: 8pt">
<tr>
<td style="width: 38px; height: 13px">
Type</td>
<td style="width: 61px; height: 13px">
Trigger states</td>
<td style="width: 61px; height: 13px">
Trigger how often</td>
<td style="width: 61px; height: 13px">
Sound</td>
<td style="width: 486px; height: 13px">
</td>
</tr>
<tr>
<td style="width: 38px; height: 13px">
0</td>
<td style="width: 61px; height: 13px">
</td>
<td style="width: 61px; height: 13px">
0</td>
<td style="width: 61px; height: 13px">
</td>
<td style="width: 486px; height: 13px">
loops mapmodel animation</td>
</tr>
<tr>
<td style="width: 38px; height: 3px">
1</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 61px; height: 3px">
1</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 486px; height: 3px">
do trigger animation when touched for the first time only and return to starting position (best for switches, use switch/lever models)</td>
</tr>
<tr>
<td style="width: 38px; height: 3px">
2</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 61px; height: 3px">
1</td>
<td style="width: 61px; height: 3px">
rumble</td>
<td style="width: 486px; height: 3px">
same as above but with sound</td>
</tr>
<tr>
<td style="width: 38px;">
3</td>
<td style="width: 61px;">
toggle (0/1) </td>
<td style="width: 61px;">
1</td>
<td style="width: 61px;">
</td>
<td style="width: 486px;">
do trigger animation when touched for the first time only and stay in toggled position (best for switches, use switch/lever models)</td>
</tr>
<tr>
<td style="width: 38px;">
4</td>
<td style="width: 61px;">
toggle (0/1) </td>
<td style="width: 61px;">
1</td>
<td style="width: 61px;">
rumble</td>
<td style="width: 486px;">
same as above but with sound</td>
</tr>
<tr>
<td style="width: 38px; height: 3px">
5</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 61px; height: 3px">
N</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 486px; height: 3px">
do trigger animation when touched every time and return to starting position (best for switches, use switch/lever models)</td>
</tr>
<tr>
<td style="width: 38px; height: 3px">
6</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 61px; height: 3px">
N</td>
<td style="width: 61px; height: 3px">
rumble</td>
<td style="width: 486px; height: 3px">
same as above but with sound</td>
</tr>
<tr>
<td style="width: 38px; height: 3px">
7</td>
<td style="width: 61px; height: 3px">
toggle (0/1) </td>
<td style="width: 61px; height: 3px">
N</td>
<td style="width: 61px; height: 3px">
</td>
<td style="width: 486px; height: 3px">
do trigger animation when touched every time and toggle positions (best for reversible switches, use switch/lever models)</td>
</tr>
<tr>
<td style="width: 38px; height: 3px">
8</td>
<td style="width: 61px; height: 3px">
toggle (0/1)</td>
<td style="width: 61px; height: 3px">
N</td>
<td style="width: 61px; height: 3px">
rumble</td>
<td style="width: 486px; height: 3px">
same as above but with sound</td>
</tr>
<tr>
<td style="width: 38px; height: 13px">
9</td>
<td style="width: 61px; height: 13px">
closed/open (0/1)</td>
<td style="width: 61px; height: 13px">
1</td>
<td style="width: 61px; height: 13px">
door?</td>
<td style="width: 486px; height: 13px">
opened by approach first time only, stays open afterwards. Collides while closed. (use door specific models)</td>
</tr>
<tr>
<td style="width: 38px; height: 13px">
10</td>
<td style="width: 61px; height: 13px">
closed/open (0/1)</td>
<td style="width: 61px; height: 13px">
N</td>
<td style="width: 61px; height: 13px">
door?</td>
<td style="width: 486px; height: 13px">
opened by approach every time, closes after 5 seconds. Collides while closed. (use door specific models)</td>
</tr>
<tr>
<td style="width: 38px">
11</td>
<td style="width: 61px">
locked (-1) </td>
<td style="width: 61px">
0/N</td>
<td style="width: 61px">
door?</td>
<td style="width: 486px">
opened/closed only by associated trigger. When approached while closed, collides and invokes level trigger with triggerstate -1. (use door specific models)</td>
</tr>
<tr>
<td style="width: 38px; height: 13px">
12</td>
<td style="width: 61px; height: 13px">
disappear (0)</td>
<td style="width: 61px; height: 13px">
1</td>
<td style="width: 61px; height: 13px">
</td>
<td style="width: 486px; height: 13px">
do trigger animation once when touched, disappear after (good for triggers that look more like pickups, such as the carrot)</td>
</tr>
<tr>
<td style="width: 38px">
13</td>
<td style="width: 61px">
disappear (0)</td>
<td style="width: 61px">
1</td>
<td style="width: 61px">
rumble</td>
<td style="width: 486px">
same as above but with sound</td>
</tr>
<tr>
<td style="width: 38px; height: 13px">
29</td>
<td style="width: 61px; height: 13px">
disappear (0)</td>
<td style="width: 61px; height: 13px">
1</td>
<td style="width: 61px; height: 13px">
end?</td>
<td style="width: 486px; height: 13px">
FPS specific. END LEVEL</td>
</tr>
</table>
<br />
Be careful when using "switch many" for thing that affect gameplay, such as opening
doors, as it can be confusing. Best is to reserve a particular model to mean "many"
and others "once".<br />
All types &gt;0 are snapped to 15 degree angles for orientation.&nbsp;<br />

</p>

<pre>"monster" N</pre>
<p>
A monster, currently N = 0..4 (see gameplay docs). Monster entities will be
spawned when in classic single player mode, and will attack you when you come
into view. yaw is taken from the current camera yaw.
<br />

</p>

<pre>"respawnpoint"</pre>
<p>

A respawnpoint for classic SP mode (see "SP Respawning"). Place these spaced evenly in quieter areas between fights. Will actually work in
any game mode, just probably isn't helpful in DM.

Entities are shown in editmode by blue sparklies, and the closest one is
indicated on the HUD.

<a name="hud"></a>        
<h1>The HUD</h1>
On the bottom left of the screen are a bunch of stats. You'll find out what they mean below.
<ul>
<li>
cube: the number of cubes in the current selection. Only the visible (leaf)
cubes are counted.
<li>
fps: frames per second
<li>
ond: number of cubes in the system. This includes parent cubes, copied cubes,
and undos.
<li>
va: number of vertex arrays used to store vertecies in the map. you probably
don't need to use this.
<li>
vtr: number of triangles currently being displayed. will be a useful stat when
culling is done.
<li>
vvt: number of vertecies currently being displayed. again, useful when culling
is done.
<li>
tri: number of triangles in the entire map
<li>
wvt: number of vertecies in the entire map
<li>
evt: misc rendering effects. stuff like particles displayed, or text written on
screen.</li></ul>
</p>

<pre>hidestats 0/1</pre>
<p>
Turn on to hide the above stats
</p>

<pre>hidehud 0/1</pre>
<p>
Turn on to hide all HUD elements
</body>
</html>
