#include "pch.h"
#include "engine.h"

enum                              // block types, order matters!
{
    C_SOLID = 0,                  // entirely solid cube [only specifies wtex]
    C_CORNER,                     // half full corner of a wall
    C_FHF,                        // floor heightfield using neighbour vdelta values
    C_CHF,                        // idem ceiling
    C_SPACE,                      // entirely empty cube
    C_SEMISOLID,                  // generated by mipmapping
	C_MAXTYPE
};
 
struct c_sqr
{
    uchar type;                 // one of the above
    char floor, ceil;           // height, in cubes
    uchar wtex, ftex, ctex;     // wall/floor/ceil texture ids
    uchar vdelta;               // vertex delta, used for heightfield cubes
    uchar utex;                 // upper wall tex id
};

struct c_persistent_entity        // map entity
{
    short x, y, z;              // cube aligned position
    short attr1;
    uchar type;                 // type is one of the above
    uchar attr2, attr3, attr4;        
};

struct c_header                   // map file format header
{
    char head[4];               // "CUBE"
    int version;                // any >8bit quantity is a little indian
    int headersize;             // sizeof(header)
    int sfactor;                // in bits
    int numents;
    char maptitle[128];
    uchar texlists[3][256];
    int waterlevel;
    int reserved[15];
};

void create_ent(c_persistent_entity &ce)
{
	if(ce.type==ET_MAPMODEL) return;	// FIXME
    extentity &e = *newentity();
    ents.add(&e);
	e.type = ce.type;
	e.spawned = false;
	e.o = vec(ce.x*4+hdr.worldsize/4, ce.y*4+hdr.worldsize/4, ce.z*4+hdr.worldsize/2);
	e.color[0] = e.color[1] = e.color[2] = 255; 
	e.attr1 = ce.attr1;
	e.attr2 = ce.attr2;
	e.attr3 = ce.attr3;
	e.attr4 = ce.attr4;
	e.attr5 = 0;
};

cube &getcube(int x, int y, int z)
{
	return lookupcube(x*4+hdr.worldsize/4, y*4+hdr.worldsize/4, z*4+hdr.worldsize/2, 4);
};

int neighbours(c_sqr &t, c_sqr **s, int ssize)
{
	s[0] = &t;
	s[1] = &t+1;		
	s[2] = &t+ssize;	
	s[3] = &t+ssize+1;
	int best = 0xFFFF;
	loopi(4) if(s[i]->vdelta<best) best = s[i]->vdelta;
	return best;
};

void preprocess_cubes(c_sqr *world, int ssize)		// pull up heighfields to where they don't cross cube boundaries
{
	c_sqr *s[4];
	for(;;)
	{
		bool changed = false;
		loop(x, ssize)
		{
			loop(y, ssize)
			{
				c_sqr &t = world[x+y*ssize];
				if(t.type==C_FHF || t.type==C_CHF)
				{
					int bottom = (neighbours(t, s, ssize)&(~3))+4;
					loopj(4) if(s[j]->vdelta>bottom) { s[j]->vdelta = bottom; changed = true; };
				};
			};
		};
		if(!changed) break;
	};
};

void hf(int x, int y, int z, int side, int dir, c_sqr **o, int cap)
{
	cube &c = getcube(x, y, z);
	loopi(4) c.edges[i] = edgeset(c.edges[i], side, dir*(o[i]->vdelta-cap)*2+side*8);
};

bool cornersolid(int z, c_sqr *s) { return s->type==C_SOLID || z<s->floor || z>=s->ceil; };

void createcorner(cube &c, int lstart, int lend, int rstart, int rend)
{
	int ledge = edgemake(lstart, lend);
	int redge = edgemake(rstart, rend);
	c.edges[4] = ledge;
	c.edges[5] = ledge;
	c.edges[6] = redge;
	c.edges[7] = redge;
};

void create_cubes(c_sqr *world, int ssize)
{
	c_sqr *o[4];
	loop(x, ssize)
	{
		loop(y, ssize)
		{
			c_sqr &s = world[x+y*ssize];
			int floor = s.floor;
			int ceil = s.ceil;
			int cap;
			switch(s.type)
			{
				case C_SOLID: floor = ceil; break;
				case C_FHF: floor -= (cap = neighbours(s, o, ssize)&(~3))/4; break;
				case C_CHF: ceil  += (cap = neighbours(s, o, ssize)&(~3))/4; break;
			};
			for(int z = -128; z<128; z++)
			{
				cube &c = getcube(x, y, z);
				c.texture[2] = c.texture[3] = c.texture[4] = c.texture[5] = s.type!=C_SOLID && z<ceil ? s.wtex : s.utex;  
				c.texture[0] = s.ctex;
				c.texture[1] = s.ftex;
				if(z>=floor && z<ceil)
				{
					setfaces(c, F_EMPTY);
				}
				else if(s.type==C_CORNER)
				{
					c_sqr *ts, *bs, *ls, *rs;
					bool tc = cornersolid(z, ts = &s-ssize);
					bool bc = cornersolid(z, bs = &s+ssize);
					bool lc = cornersolid(z, ls = &s-1);
					bool rc = cornersolid(z, rs = &s+1);
					if     (tc && lc && !bc && !rc) createcorner(c, 0, 8, 0, 0);	// TOP LEFT
					else if(tc && !lc && !bc && rc) createcorner(c, 0, 0, 0, 8);	// TOP RIGHT
					else if(!tc && lc && bc && !rc) createcorner(c, 0, 8, 8, 8);	// BOT LEFT
					else if(!tc && !lc && bc && rc) createcorner(c, 8, 8, 0, 8);	// BOT RIGHT	
					else		// fix texture on ground of a corner
					{
						if      (ts->floor-1==z && bs->floor-1!=z) { c.texture[1] = ts->ftex; }
						else if (ts->floor-1!=z && bs->floor-1==z) { c.texture[1] = bs->ftex; };
						if      (ts->ceil==z && bs->ceil!=z)       { c.texture[0] = ts->ctex; }
						else if (ts->ceil!=z && bs->ceil==z)       { c.texture[0] = bs->ctex; };
					};
				};
			};
			switch(s.type)
			{
				case C_FHF: hf(x, y, floor-1, 1, -1, o, cap); break;
				case C_CHF: hf(x, y, ceil, 0, 1, o, cap); break;
			};
		};
	};
};

void load_cube_world(char *mname)       
{
	empty_world(11, true);
	freeocta(worldroot);
	worldroot = newcubes(F_SOLID);
	string cgzname; 
    sprintf_s(cgzname)("packages/cube/%s.cgz", mname);
    gzFile f = gzopen(path(cgzname), "rb9");
    if(!f) { conoutf("could not read cube map %s", cgzname); return; };
	c_header hdr;
    gzread(f, &hdr, sizeof(c_header)-sizeof(int)*16);
    endianswap(&hdr.version, sizeof(int), 4);
    if(strncmp(hdr.head, "CUBE", 4)!=0) fatal("while reading map: header malformatted");
    if(hdr.version>5) fatal("this map requires a newer version of cube");
    if(hdr.version>=4)
    {
        gzread(f, &hdr.waterlevel, sizeof(int)*16);
        endianswap(&hdr.waterlevel, sizeof(int), 16);
    }
    else
    {
        hdr.waterlevel = -100000;
    };
    loopi(hdr.numents)
    {
        c_persistent_entity e;
        gzread(f, &e, sizeof(c_persistent_entity));
        endianswap(&e, sizeof(short), 4);
		create_ent(e);
    };
	int ssize = 1<<hdr.sfactor;
	c_sqr *world = new c_sqr[ssize*ssize];
    c_sqr *t = NULL;
    loopk(ssize*ssize)
    {
        c_sqr *s = &world[k];
        int type = gzgetc(f);
        switch(type)
        {
            case 255:  
            {
                int n = gzgetc(f);
                for(int i = 0; i<n; i++, k++) memcpy(&world[k], t, sizeof(c_sqr));
                k--;
                break;
            };
            case 254: // only in MAPVERSION<=2
            {
                memcpy(s, t, sizeof(c_sqr));
                gzgetc(f);
                gzgetc(f);
                break;
            };
            case C_SOLID:
            {
                s->type = C_SOLID;
                s->wtex = gzgetc(f);
                s->vdelta = gzgetc(f);
                if(hdr.version<=2) { gzgetc(f); gzgetc(f); };
                s->ftex = DEFAULT_FLOOR;
                s->ctex = DEFAULT_CEIL;
                s->utex = s->wtex;
                s->floor = 0;
                s->ceil = 16;
                break;
            };
            default:
            {
                if(type<0 || type>=C_MAXTYPE)
                {
                    sprintf_sd(t)("%d @ %d", type, k);
                    fatal("while reading map: type out of range: ", t);
                };
                s->type = type;
                s->floor = gzgetc(f);
                s->ceil = gzgetc(f);
                if(s->floor>=s->ceil) s->floor = s->ceil-1;  // for pre 12_13
                s->wtex = gzgetc(f);
                s->ftex = gzgetc(f);
                s->ctex = gzgetc(f);
                if(hdr.version<=2) { gzgetc(f); gzgetc(f); };
                s->vdelta = gzgetc(f);
                s->utex = (hdr.version>=2) ? gzgetc(f) : s->wtex;
                if(hdr.version>=5) gzgetc(f);
                s->type = type;
            };
        };
        t = s;
    };
    gzclose(f);
	preprocess_cubes(world, ssize);
	create_cubes(world, ssize);
	extern void remop();
	remop();
	loopv(ents) if(ents[i]->type!=ET_LIGHT) dropenttofloor(ents[i]);
	string cfgname;
    sprintf_s(cfgname)("packages/cube/%s.cfg", mname);
    exec("packages/cube/package.cfg");
	exec(path(cfgname));
    conoutf("read cube map %s (%d milliseconds)", cgzname, SDL_GetTicks()-lastmillis);
};

COMMANDN(importcube, load_cube_world, ARG_1STR);
