// standard shader definitions

alias vpstart [
	!!ARBvp1.0
	ATTRIB opos = vertex.position; 
	OUTPUT spos = result.position; 
	DP4 spos.x, state.matrix.mvp.row[0], opos; 
	DP4 spos.y, state.matrix.mvp.row[1], opos; 
	DP4 spos.z, state.matrix.mvp.row[2], opos; 
	DP4 spos.w, state.matrix.mvp.row[3], opos;
]

macro normalize [
	DP3 %1.w, %2, %2;
	RSQ %1.w, %1.w;
	MUL %1.xyz, %1.w, %2;
]

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader "default" [		
	@vpstart
	MOV result.texcoord[0], vertex.texcoord[0];
	MOV result.color, vertex.color;
	END
] [
	!!ARBfp1.0
	TEMP diffuse;
	TEX diffuse, fragment.texcoord[0], texture[0], 2D;
	MUL result.color, fragment.color, diffuse;
	END
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader "notexture" [		
	@vpstart
	MOV result.color, vertex.color;
	END
] [
	!!ARBfp1.0
	MOV result.color, fragment.color;
	END
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

macro worldshader [
	shader %1 [
		@vpstart
		DP3 result.texcoord[0].x, opos, program.env[0];
		DP3 result.texcoord[0].y, opos, program.env[1];
		DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
		DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];
		DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
		MOV result.color, vertex.color;
		END
	] [
		!!ARBfp1.0
		OPTION ARB_fog_linear;
		TEMP diffuse, lm;
		TEX diffuse, fragment.texcoord[0], texture[0], 2D;
		TEX lm,      fragment.texcoord[1], texture[1], 2D;
		%2						# insert optional blending
		MUL diffuse, diffuse, 2;
		MUL diffuse, diffuse, fragment.color;	# only really needed for showva atm 
		MUL result.color, diffuse, lm;
		END
	]
]

alias worldshaders [
	@[worldshader "stdworld" " "]
	@[worldshader "decalworld" [
		TEMP decal;
		TEX decal,   fragment.texcoord[0], texture[2], 2D;
		LRP diffuse, decal.w, decal, diffuse;
	]]
]
worldshaders



////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

shader "stdppmodel" [
	@vpstart
	ATTRIB onormal = vertex.normal; 
	PARAM ocampos = program.env[1];
	PARAM lightdir = program.env[0];
	OUTPUT wnormal = result.texcoord[1]; 
	TEMP halfangle;
	MOV result.texcoord[0], vertex.texcoord[0];
	MOV wnormal, onormal;
	MOV result.color, vertex.color;
	SUB halfangle, ocampos, opos;
	@[normalize halfangle halfangle]
	ADD result.texcoord[3], lightdir, halfangle;
	MOV result.texcoord[2], lightdir;
	DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
	END
] [
	!!ARBfp1.0
	OPTION ARB_fog_linear;
	ATTRIB normal = fragment.texcoord[1];
	ATTRIB lightdir = fragment.texcoord[2];
	ATTRIB halfangle = fragment.texcoord[3];
	PARAM specintensity = program.env[2];
	PARAM ambient = program.env[3];
	TEMP diffuse, rnormal, rhalfangle, light, spec, x;

	@[normalize rhalfangle halfangle]

	@[normalize rnormal normal]

	DP3_SAT spec, rhalfangle, rnormal;
	MOV x, 128;
	POW spec, spec.x, x.x;
	MUL spec, spec, specintensity;

	DP3_SAT light, rnormal, lightdir;
	MUL light, light, 1.5;
	MAX light, light, ambient;

	TEX diffuse, fragment.texcoord[0], texture[0], 2D;
	MAD light, light, diffuse, spec;
	MUL result.color, light, fragment.color;
	END
]

////////////////////////////////////////////////
//
// phong lighting model shader with specmap & glowmap
// FIXME: refactor these better
//
////////////////////////////////////////////////

shader "masksppmodel" [
	@vpstart
	ATTRIB onormal = vertex.normal; 
	PARAM ocampos = program.env[1];
	PARAM lightdir = program.env[0];
	OUTPUT wnormal = result.texcoord[1]; 
	TEMP halfangle;
	MOV result.texcoord[0], vertex.texcoord[0];
	MOV wnormal, onormal;
	MOV result.color, vertex.color;
	SUB halfangle, ocampos, opos;
	@[normalize halfangle halfangle]
	ADD result.texcoord[3], lightdir, halfangle;
	MOV result.texcoord[2], lightdir;
	DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
	END
] [
	!!ARBfp1.0
	OPTION ARB_fog_linear;
	ATTRIB normal = fragment.texcoord[1];
	ATTRIB lightdir = fragment.texcoord[2];
	ATTRIB halfangle = fragment.texcoord[3];
	PARAM specintensity = program.env[2];
	PARAM ambient = program.env[3];
	TEMP diffuse, rnormal, rhalfangle, light, spec, x, masks, color;

	@[normalize rhalfangle halfangle]

	@[normalize rnormal normal]

	TEX masks, fragment.texcoord[0], texture[1], 2D;
	ADD_SAT color, fragment.color, masks.yyyy;	# glowmap in green channel FIXME only do this once

	DP3_SAT spec, rhalfangle, rnormal;
	MOV x, 128;
	POW spec, spec.x, x.x;
	MUL spec, spec, specintensity;
	MUL spec, spec, masks.x;	        # specmap in red channel

	DP3_SAT light, rnormal, lightdir;
	LRP light, masks.yyyy, 2, light;	# glowmap in green channel
	MUL light, light, 1.5;
	MAX light, light, ambient;


	TEX diffuse, fragment.texcoord[0], texture[0], 2D;
	MAD light, light, diffuse, spec;
	MUL result.color, light, color;
	END
]

////////////////////////////////////////////////
//
// gourad lighting model shader: cheaper, non-specular version for vegetation etc. gets used when spec==0
//
////////////////////////////////////////////////

shader "nospecpvmodel" [
	@vpstart
	ATTRIB onormal = vertex.normal; 
	PARAM ocampos = program.env[1];
	PARAM lightdir = program.env[0];
	PARAM ambient = program.env[3];
	TEMP light;

	MOV result.texcoord[0], vertex.texcoord[0];

	DP3 light, onormal, lightdir;
	MUL light, light, 1.5;
	MAX light, light, ambient;
	MUL result.texcoord[1], light, vertex.color;

	DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
	END
] [
	!!ARBfp1.0
	OPTION ARB_fog_linear;
	ATTRIB light = fragment.texcoord[1];
	TEMP diffuse;

	TEX diffuse, fragment.texcoord[0], texture[0], 2D;
	MUL result.color, light, diffuse;
	END
]



////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////


alias fsvs [
	!!ARBvp1.0
	MOV result.position, vertex.position;   # woohoo, no mvp :) 
	MOV result.texcoord[0], vertex.texcoord[0];
	END
]

alias fsps [
	!!ARBfp1.0
	TEMP sample;
	TEX sample, fragment.texcoord[0], texture[0], 2D;
]

macro samplecorner [
	ADD %1, fragment.texcoord[0], program.env[%2];		# env 0..3 are the corner pixel offsets
	TEX %1, %1, texture[0], 2D;
]

alias sample4corners [
	TEMP s00, s02, s20, s22;
	@[samplecorner s00 0]
	@[samplecorner s02 1]
	@[samplecorner s20 2]
	@[samplecorner s22 3]
]

// some simple ones that just do an effect on the RGB value...

shader "invert" [ @fsvs ] [ @fsps SUB result.color, 1, sample;   END ]
shader "gbr"    [ @fsvs ] [ @fsps MOV result.color, sample.yzxw; END ]

// sobel

shader "sobel"  [ @fsvs ] [
	@fsps
	@sample4corners

	TEMP t, u;

	ADD t, s00, s20;
	SUB t, t, s02;
	SUB t, t, s22;
	MUL t, t, t;

	ADD u, s00, s02;
	SUB u, u, s20;
	SUB u, u, s22;
	MUL u, u, u;

	ADD t, t, u;

	ADD result.color, sample, t;
	#MOV result.color, t;
	END
]


// bloom-ish

shader "bloom_scale"   [ @fsvs ] [
	@fsps
	@sample4corners

	TEMP t;
	ADD t, s02, s00;
	ADD t, s22, t;
	ADD t, s20, t;
	ADD t, t, sample;
	MUL t, t, 0.2;
	#MUL t, t, t;
	#MUL t, t, program.env[4];
	#MUL t, t, 20;
	MUL result.color, t, t; 
	END
]

shader "bloom"   [ @fsvs ] [
	@fsps
	TEMP sample2, sample3, sample4, sample5, sample6, sample7;
	TEX sample2, fragment.texcoord[0], texture[1], 2D;
	TEX sample3, fragment.texcoord[0], texture[2], 2D;
	TEX sample4, fragment.texcoord[0], texture[3], 2D;
	TEX sample5, fragment.texcoord[0], texture[4], 2D;
	TEX sample6, fragment.texcoord[0], texture[5], 2D;
	TEX sample7, fragment.texcoord[0], texture[6], 2D;
	#MOV sample, 0;
	MAD sample, sample2, 1, sample;
	MAD sample, sample3, 2, sample;
	MAD sample, sample4, 3, sample;
	MAD sample, sample5, 4, sample;
	MAD sample, sample6, 5, sample;
	MAD sample, sample7, 6, sample;
	MOV result.color, sample;
	END
]



