// standard shader definitions

fpopts = [
    @(if (= $shaderprecision 1) [result "OPTION ARB_precision_hint_fastest;"])
    @(if (= $shaderprecision 3) [result "OPTION ARB_precision_hint_nicest;"])
]

vpstart = [
	!!ARBvp1.0
    OPTION ARB_position_invariant;
	ATTRIB opos = vertex.position; 
]

fpstart = [
    !!ARBfp1.0
    @fpopts
]

macro normalize [
	DP3 %1.w, %2, %2;
	RSQ %1.w, %1.w;
	MUL %1.xyz, %1.w, %2;
]

fogcoord = [
    TEMP fogplane;
    MAD fogplane, state.matrix.modelview.row[2], program.env[9].x, program.env[9].yyzw;
    DP4 result.fogcoord, -opos, fogplane;
]

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader 0 "default" [		
	@vpstart
	MOV result.texcoord[0], vertex.texcoord[0];
	MOV result.color, vertex.color;
	END
] [
    @fpstart
	TEMP diffuse;
	TEX diffuse, fragment.texcoord[0], texture[0], 2D;
	MUL result.color, fragment.color, diffuse;
	END
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader 0 "notexture" [		
	@vpstart
	MOV result.color, vertex.color;
	END
] [
    @fpstart
	MOV result.color, fragment.color;
	END
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    @vpstart
    END
] [
    @fpstart
    END
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
	shader 0 $arg1 [
		@vpstart
		DP3 result.texcoord[0].x, opos, program.env[0];
		DP3 result.texcoord[0].y, opos, program.env[1];
		DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
		DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];
        @fogcoord
		MOV result.color, vertex.color;
		END
	] [
        @fpstart
		OPTION ARB_fog_linear;
		TEMP diffuse, lm;
		TEX diffuse, fragment.texcoord[0], texture[0], 2D;
		TEX lm,      fragment.texcoord[1], texture[1], 2D;
		@arg2
		MUL diffuse, diffuse, 2;
		MUL result.color, diffuse, lm;

		END
	]
]

worldshader "stdworld" ""
worldshader "decalworld" [
	TEMP decal;
	TEX decal,   fragment.texcoord[0], texture[2], 2D;
	LRP diffuse, decal.w, decal, diffuse;
]

shader 0 "fogworld" [
    @vpstart
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    END
]

bumpshader = [
    spec = $arg2
	parallax = $arg3		// overridden by normalize, ugh
    shader 1 $arg1 [
	    @vpstart
	    DP3 result.texcoord[0].x, opos, program.env[0];
	    DP3 result.texcoord[0].y, opos, program.env[1];
	    DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
	    DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];
        @fogcoord
    	
        @(if $spec [result [
    	    TEMP camv, camvts, normal, tangent, binormal, x, y;
    	    MAD normal, vertex.color, 2, -1;
	    
    	    # TS gram-schmidt orthonormalization, needed for non-90 degree surfaces (expensive, TS only used for eye vector! can remove if no spec/parallax)
    	    DP3 x, normal, program.env[2];
    	    MUL x, x, normal;
    	    SUB tangent, program.env[2], x;
    	    DP3 x, tangent, program.env[3];
    	    MUL x, x, tangent;
            DP3 y, normal, program.env[3];
            MUL y, y, normal;
            SUB binormal, program.env[3], x;
            SUB binormal, binormal, y;
    	
	        # trans eye vector into TS
	        SUB camv, program.env[4], opos;
	        DP3 result.texcoord[7].x, camv, tangent;
	        DP3 result.texcoord[7].y, camv, binormal;
	        DP3 result.texcoord[7].z, camv, normal;
	    ]])

	    END
    ] [
        @fpstart
	    OPTION ARB_fog_linear;
	    TEMP diffuse, lmc, lmlv, bump, camvts, he, height, dtc, light;

	    TEX lmc,  fragment.texcoord[1], texture[1], 2D;
	    TEX lmlv, fragment.texcoord[1], texture[2], 2D;
	    MAD lmlv, lmlv, 2, -1;	
    
        @(if $spec [result [@(normalize camvts fragment.texcoord[7])]])
        @(if (> $spec 1) [result [
	        ADD he, camvts, lmlv;
	        @(normalize he he) 
        ]])

        @parallax

	    TEX diffuse, dtc, texture[0], 2D;
	    TEX bump,    dtc, texture[3], 2D;
	    MAD bump.xyz, bump, 2, -1;
    	
        @(if (> $spec 1) [result [
            PARAM specfactor = 32;

	        DP3_SAT he, he, bump;
	        POW he, he.x, specfactor.x;
	    ]])

	    @arg4
    	
	    DP3_SAT bump, bump, lmlv;
        MUL light, lmc, bump;
        MAX light, light, program.env[5];

        @(if $spec [result [MAD diffuse, diffuse, 2, he;]] [result [MUL diffuse, diffuse, 2;]])

	    @arg5

	    END
    ]
]

bumpshader "bumpworld" 0      [ MOV dtc, fragment.texcoord[0]; ] [] [ MUL result.color, light, diffuse; ]

setpixelparam 1 1 1 1
bumpshader "bumpspecworld" 2        [ MOV dtc, fragment.texcoord[0]; ] [ MUL he, he, program.env[11]; ] [ MUL result.color, light, diffuse; ]
fastshader bumpspecworld bumpworld 2

setpixelparam 1 6 6 6       // spec map multiplier
bumpshader "bumpspecmapworld" 2     [ MOV dtc, fragment.texcoord[0]; ] [ MUL he, he, program.env[11]; MUL he, he, bump.w; ] [ MUL result.color, light, diffuse; ]
fastshader bumpspecmapworld bumpworld 2

setpixelparam 0 1 1 1       // glow color
setpixelparam 1 6 6 6      // spec map multiplier
bumpshader "bumpspecmapglowworld" 2 [ MOV dtc, fragment.texcoord[0]; ] [ MUL he, he, program.env[11]; MUL he, he, bump.w; ] [
    TEMP glow;
	TEX glow, dtc, texture[4], 2D;
    MUL glow, glow, program.env[10];
    MAD result.color, light, diffuse, glow;
]
setpixelparam 0 1 1 1      // glow color
bumpshader "bumpglowworld" 0  [ MOV dtc, fragment.texcoord[0]; ] [] [
    TEMP glow;
    TEX glow, dtc, texture[4], 2D;
    MUL glow, glow, program.env[10];
    MAD result.color, light, diffuse, glow;
]
fastshader bumpspecmapglowworld bumpglowworld 2

setpixelparam 1 1 1 1
bumpshader "bumpspecparallaxworld" 2 [
    TEX height, fragment.texcoord[0], texture[3], 2D;
    MAD height.w, height.w, 0.02, -0.01;	# 0.04, -0.02;	    # current textures don't allow for much parallax scaling before it distorts
    MAD dtc, height.w, camvts, fragment.texcoord[0];
] [ MUL he, he, program.env[11]; ] [ MUL result.color, light, diffuse; ]
setpixelparam 1 6 6 6
bumpshader "bumpspecmapparallaxworld" 2 [
    TEX height, fragment.texcoord[0], texture[3], 2D;
    MAD height.w, height.w, 0.02, -0.01;    # 0.04, -0.02;      # current textures don't allow for much parallax scaling before it distorts
    MAD dtc, height.w, camvts, fragment.texcoord[0];
] [ MUL he, he, program.env[11]; MUL he, he, bump.w; ] [ MUL result.color, light, diffuse; ]
bumpshader "bumpparallaxworld" 1 [
    TEX height, fragment.texcoord[0], texture[3], 2D;
    MAD height.w, height.w, 0.02, -0.01;    # 0.04, -0.02;      # current textures don't allow for much parallax scaling before it distorts
    MAD dtc, height.w, camvts, fragment.texcoord[0];
] [] [ MUL result.color, light, diffuse; ]
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpparallaxworld 2

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

modelshader = [
	col = $arg2		// overridden by normalize, ugh
	shader 0 $arg1 [
		@vpstart
		ATTRIB onormal = vertex.normal; 
		PARAM ocampos = program.env[1];
		PARAM lightdir = program.env[0];
		OUTPUT wnormal = result.texcoord[1]; 
		TEMP halfangle;
		MOV result.texcoord[0], vertex.texcoord[0];
		MOV wnormal, onormal;
		MOV result.color, vertex.color;
		SUB halfangle, ocampos, opos;
		@(normalize halfangle halfangle)
		ADD result.texcoord[3], lightdir, halfangle;
		MOV result.texcoord[2], lightdir;
        @fogcoord
		END
	] [
        @fpstart
		OPTION ARB_fog_linear;
		ATTRIB normal = fragment.texcoord[1];
		ATTRIB lightdir = fragment.texcoord[2];
		ATTRIB halfangle = fragment.texcoord[3];
        PARAM specfactor = 128;
		PARAM specintensity = program.env[2];
		PARAM ambient = program.env[3];
		TEMP diffuse, rnormal, rhalfangle, light, spec;

		@(normalize rhalfangle halfangle)
		@(normalize rnormal normal)

		DP3_SAT spec, rhalfangle, rnormal;
		POW spec, spec.x, specfactor.x;
		MUL spec, spec, specintensity;

		DP3_SAT light, rnormal, lightdir;

		@arg3
		
		MUL light, light, 1.5;
		MAX light, light, ambient;

		TEX diffuse, fragment.texcoord[0], texture[0], 2D;
		MAD light, light, diffuse, spec;
		MUL result.color, light, @col; 
		END
	]
]

modelshader "stdppmodel" "fragment.color" ""
modelshader "masksppmodel" "color" [			# specmap & glowmap version
	TEMP masks, color;
	TEX masks, fragment.texcoord[0], texture[1], 2D;
	ADD_SAT color, fragment.color, masks.yyyy;	# glowmap in green channel FIXME only do this once
	LRP light, masks.yyyy, 2, light;			# glowmap in green channel
	MUL spec, spec, masks.x;					# specmap in red channel
] 

////////////////////////////////////////////////
//
// gourad lighting model shader: cheaper, non-specular version for vegetation etc. gets used when spec==0
//
////////////////////////////////////////////////

alias nospecmodelshader [
    shader 0 $arg1 [
	    @vpstart
        ATTRIB onormal = vertex.normal; 
	    PARAM ocampos = program.env[1];
	    PARAM lightdir = program.env[0];
	    PARAM ambient = program.env[3];
	    TEMP light;

	    MOV result.texcoord[0], vertex.texcoord[0];

	    DP3 light, onormal, lightdir;
	    MUL light, light, 1.5;
	    MAX light, light, ambient;
	    MUL result.texcoord[1], light, vertex.color;

        @fogcoord
	    END
    ] [
        @fpstart
	    OPTION ARB_fog_linear;
	    ATTRIB light = fragment.texcoord[1];
	    TEMP diffuse;

	    TEX diffuse, fragment.texcoord[0], texture[0], 2D;

        @arg2

	    END
    ]
]

nospecmodelshader nospecpvmodel [MUL result.color, light, diffuse;]
nospecmodelshader masksnospecpvmodel [
    TEMP glow;
    TEX glow, fragment.texcoord[0], texture[1], 2D;
    MAD glow, glow.yyyy, 2, light;
    MUL result.color, glow, diffuse;
]   

fastshader stdppmodel nospecpvmodel 1
fastshader masksppmodel masksnospecpvmodel 1

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////


fsvs = [
	!!ARBvp1.0
	MOV result.position, vertex.position;   # woohoo, no mvp :) 
	MOV result.texcoord[0], vertex.texcoord[0];
]

fsps = [
    @fpstart
	TEMP sample;
	TEX sample, fragment.texcoord[0], texture[0], RECT;
]

setup4corners = [
	ADD result.texcoord[1], vertex.texcoord[0], { -1, -1, 0, 0 };		
	ADD result.texcoord[2], vertex.texcoord[0], {  1, -1, 0, 0 };		
	ADD result.texcoord[3], vertex.texcoord[0], { -1,  1, 0, 0 };		
	ADD result.texcoord[4], vertex.texcoord[0], {  1,  1, 0, 0 };		
]

sample4corners = [
	TEMP s00, s02, s20, s22;
	TEX s00, fragment.texcoord[1], texture[0], RECT;
	TEX s02, fragment.texcoord[2], texture[0], RECT;
	TEX s20, fragment.texcoord[3], texture[0], RECT;
	TEX s22, fragment.texcoord[4], texture[0], RECT;
]

// some simple ones that just do an effect on the RGB value...

shader 0 "invert" [ @fsvs END ] [ @fsps SUB result.color, 1, sample;   END ]
shader 0 "gbr"    [ @fsvs END ] [ @fsps MOV result.color, sample.yzxw; END ]

// sobel

shader 0 "sobel"  [ @fsvs @setup4corners END ] [
	@fsps
	@sample4corners

	TEMP t, u;

	ADD t, s00, s20;
	SUB t, t, s02;
	SUB t, t, s22;
	MUL t, t, t;

	ADD u, s00, s02;
	SUB u, u, s20;
	SUB u, u, s22;
	MUL u, u, u;

	ADD t, t, u;

	ADD result.color, sample, t;
	END
]


// bloom-ish

shader 0 "bloom_scale"   [ @fsvs @setup4corners END ] [
	@fsps
	@sample4corners

	TEMP t;
	ADD t, s02, s00;
	ADD t, t, s22;
	ADD t, t, s20;
	ADD t, t, sample;
	MUL result.color, t, 0.2; 
	END
]

shader 0 "bloom"   [ 
    @fsvs
    TEMP tc;
    MOV tc, vertex.texcoord[0];
    @(loopconcat i 6 [concat "MUL tc, tc, 0.5; MOV result.texcoord[" (+ $i 1) "], tc;"])
    END
] [
	@fsps
	TEMP scaled, t;
    @(loopconcat i 6 [
        format [ 
            TEX scaled, fragment.texcoord[%1], texture[%1], RECT;
            DP3 t, scaled, { 0.3, 0.5, 0.2, 1 };    # luminosity filter
            MUL t, t, t;
            MUL t, t, scaled;
            MAD sample, t, program.env[0].x, sample;
        ] (+ $i 1)
      ]
    )
	MOV result.color, sample;
	END
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
shader 0 "explosion" [
    !!ARBvp1.0
    ATTRIB opos = vertex.position; 
    OUTPUT spos = result.position; 
    TEMP wobble;

    DP3 wobble, opos, program.env[0]; # generate wobble offset based off vertex normal and sphere center
    MAD wobble, program.env[1].xxxx, 1.5, wobble; # wobble frequency
    FRC wobble, wobble; # 0..1
    SUB wobble, wobble, 0.5; # -0.5..0.5
    ABS wobble, wobble; # now oscillates up and down between 0..0.5
    MAD wobble, wobble, 0.5, -0.125; # wobble amplitude
    
    MOV wobble.w, 0;
    MAD wobble, wobble, opos, opos;

    DP4 spos.x, state.matrix.mvp.row[0], wobble; 
    DP4 spos.y, state.matrix.mvp.row[1], wobble; 
    DP4 spos.z, state.matrix.mvp.row[2], wobble; 
    DP4 spos.w, state.matrix.mvp.row[3], wobble;

    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL result.color, fragment.color, diffuse;
    END
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

alias watershader [
    spec = $arg2
    distort = $arg3
    combine = $arg4
    shader 1 $arg1 [
        @vpstart
        TEMP tc;
        PARAM campos = program.env[0];
        PARAM seconds = program.env[1];
        @(if $spec [result "PARAM lightpos = program.env[2];"])

        DP4 result.texcoord[0].x, state.matrix.texture.row[0], opos;
        DP4 result.texcoord[0].y, state.matrix.texture.row[1], opos;
        DP4 result.texcoord[0].z, state.matrix.texture.row[2], opos;
        DP4 result.texcoord[0].w, state.matrix.texture.row[3], opos;
        MUL tc, vertex.texcoord[0], 0.1;
        MAD result.texcoord[1], seconds, 0.04, tc;
        MAD result.texcoord[2], seconds, -0.02, tc;
        SUB result.texcoord[3], campos, opos;
        @(if $spec [result "SUB result.texcoord[4], lightpos, opos;"])
 
        MOV result.color, vertex.color;

        END
    ] [
        @fpstart
        TEMP he, light, cam, bump, invfresnel, temp, dudv;

        ATTRIB projtc = fragment.texcoord[0];
        ATTRIB tc1 = fragment.texcoord[1];
        ATTRIB tc2 = fragment.texcoord[2];
        ATTRIB camts = fragment.texcoord[3];
        @(if $spec [result "ATTRIB lightts = fragment.texcoord[4];"])

        @(normalize cam camts)
        @(if $spec [result [
            @(normalize light lightts)
            ADD he, cam, light;
            @(normalize he he)
        ]])

        TEX dudv, tc1, texture[2], 2D;
        MAD dudv.xy, dudv, 2, -1;

        @distort

        @(if $spec [result [
            PARAM specfactor = 32;

            DP3_SAT he, he, bump;
            POW he, he.x, specfactor.w;
    
            MUL light, program.env[4], light.w;
            RCP_SAT light, light.x;
            MAD light, light, -program.env[3], program.env[3];
        ]])

        @combine

        END
    ]
]

watershader "water" 1 [
    MAD temp, dudv, 0.025, tc2; 
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    TEMP diffuse;

    MUL temp, fragment.color, program.env[5].x;
    MUL diffuse, temp, 0.6;
    DP3 invfresnel, cam, bump;
    ABS invfresnel, invfresnel;
    LRP temp, invfresnel, temp, diffuse;
    MAD result.color.xyz, he, light, temp; 
    MUL result.color.w, invfresnel, program.env[5].y;
]
watershader "waterfast" 0 [
    MAD temp, dudv, 0.025, tc2; 
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [    
    TEMP diffuse;

    MUL temp, fragment.color, program.env[5].x;
    MUL diffuse, temp, 0.6;
    DP3 invfresnel, cam, bump;
    ABS invfresnel, invfresnel;
    LRP result.color.xyz, invfresnel, temp, diffuse;
    MUL result.color.w, invfresnel, program.env[5].y;
]
fastshader water waterfast 1

watershader "waterreflect" 1 [
    TEMP diffuse;

    MAD temp, dudv, 0.4, projtc;
    TXP diffuse, temp, texture[0], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    MUL temp, fragment.color, program.env[5].x;
    LRP temp, invfresnel, temp, diffuse;
    MAD result.color.xyz, he, light, temp;
    MUL result.color.w, invfresnel, program.env[5].y;
]
watershader "waterreflectfast" 0 [
    TEMP diffuse;

    MAD temp, dudv, 0.4, projtc;
    TXP diffuse, temp, texture[0], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    MUL temp, fragment.color, program.env[5].x;
    LRP result.color.xyz, invfresnel, temp, diffuse;
    MUL result.color.w, invfresnel, program.env[5].y;
]
fastshader waterreflect waterreflectfast 2

watershader "waterrefract" 1 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xyz, projtc, temp.wwww; 
    MAD temp.xy, dudv, 0.01, temp;

    TEX reflect, temp, texture[0], 2D;
    TEX refract, temp, texture[3], 2D;
] [
    DP3_SAT invfresnel, cam, bump;
    LRP temp, invfresnel, refract, reflect;
    MAD result.color, he, light, temp;
]

watershader "waterrefractfast" 0 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;
    TXP refract, temp, texture[3], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    LRP result.color, invfresnel, refract, reflect;
]
fastshader waterrefract waterrefractfast 2
