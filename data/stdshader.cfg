// standard shader definitions

alias vpstart [
!!ARBvp1.0
ATTRIB opos = vertex.position; 
OUTPUT spos = result.position; 
DP4 spos.x, state.matrix.mvp.row[0], opos; 
DP4 spos.y, state.matrix.mvp.row[1], opos; 
DP4 spos.z, state.matrix.mvp.row[2], opos; 
DP4 spos.w, state.matrix.mvp.row[3], opos;
]

macro normalize [
DP3 %1.w, %2, %2;
RSQ %1.w, %1.w;
MUL %1.xyz, %1.w, %2;
]

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader "default" [		
@vpstart
MOV result.texcoord[0], vertex.texcoord[0];
MOV result.color, vertex.color;
END
] [
!!ARBfp1.0
TEMP diffuse;
TEX diffuse, fragment.texcoord[0], texture[0], 2D;
MUL result.color, fragment.color, diffuse;
END
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader "notexture" [		
@vpstart
MOV result.color, vertex.color;
END
] [
!!ARBfp1.0
MOV result.color, fragment.color;
END
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

shader "stdworld" [
@vpstart
DP3 result.texcoord[0].x, opos, program.env[0];
DP3 result.texcoord[0].y, opos, program.env[1];
DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];
DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
MOV result.color, vertex.color;
END
] [
!!ARBfp1.0
OPTION ARB_fog_linear;
TEMP diffuse, lm;
TEX diffuse, fragment.texcoord[0], texture[0], 2D;
TEX lm,      fragment.texcoord[1], texture[1], 2D;
MUL diffuse, diffuse, 2;
MUL diffuse, diffuse, fragment.color;	# only really needed for showva atm 
MUL result.color, diffuse, lm;
END
]

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

shader "stdppmodel" [
@vpstart
ATTRIB onormal = vertex.normal; 
PARAM ocampos = program.env[1];
PARAM lightdir = program.env[0];
OUTPUT wnormal = result.texcoord[1]; 
TEMP halfangle;
MOV result.texcoord[0], vertex.texcoord[0];
MOV wnormal, onormal;
MOV result.color, vertex.color;
SUB halfangle, ocampos, opos;
@[normalize halfangle halfangle]
ADD result.texcoord[3], lightdir, halfangle;
MOV result.texcoord[2], lightdir;
DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
END
] [
!!ARBfp1.0
OPTION ARB_fog_linear;
ATTRIB normal = fragment.texcoord[1];
ATTRIB lightdir = fragment.texcoord[2];
ATTRIB halfangle = fragment.texcoord[3];
PARAM specintensity = program.env[2];
PARAM ambient = program.env[3];
TEMP diffuse, rnormal, rhalfangle, light, spec, x;

@[normalize rhalfangle halfangle]

@[normalize rnormal normal]

DP3 spec, rhalfangle, rnormal;
MAX spec, spec, 0;
MOV x, 128;
POW spec, spec.x, x.x;
MUL spec, spec, specintensity;

DP3 light, rnormal, lightdir;
MUL light, light, 1.5;
MAX light, light, ambient;

TEX diffuse, fragment.texcoord[0], texture[0], 2D;
MAD light, light, diffuse, spec;
MUL result.color, light, fragment.color;
END
]

////////////////////////////////////////////////
//
// gourad lighting model shader: cheaper, non-specular version for vegetation etc. gets used when spec==0
//
////////////////////////////////////////////////

shader "nospecpvmodel" [
@vpstart
ATTRIB onormal = vertex.normal; 
PARAM ocampos = program.env[1];
PARAM lightdir = program.env[0];
PARAM ambient = program.env[3];
TEMP light;

MOV result.texcoord[0], vertex.texcoord[0];

DP3 light, onormal, lightdir;
MUL light, light, 1.5;
MAX light, light, ambient;
MUL result.texcoord[1], light, vertex.color;

DP4 result.fogcoord, -opos, state.matrix.modelview.row[2];
END
] [
!!ARBfp1.0
OPTION ARB_fog_linear;
ATTRIB light = fragment.texcoord[1];
TEMP diffuse;

TEX diffuse, fragment.texcoord[0], texture[0], 2D;
MUL result.color, light, diffuse;
END
]



////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////


alias fsvs [
!!ARBvp1.0
MOV result.position, vertex.position;   # woohoo, no mvp :) 
MOV result.texcoord[0], vertex.texcoord[0];
END
]

alias fsps [
!!ARBfp1.0
TEMP sample;
TEX sample, fragment.texcoord[0], texture[0], 2D;
]


// some simple ones that just do an effect on the RGB value...

shader "invert" [ @fsvs ] [ @fsps SUB result.color, 1, sample; END ]
shader "gbr"    [ @fsvs ] [ @fsps MOV result.color, sample.yzxw; END ]

// sobel

// offset must be relative to number of pixels... tweaked for 1024x768
alias sample_offset 0.0014

shader "sobel"  [ @fsvs ] [
@fsps

TEMP s00, s02, s20, s22;
ADD s00, fragment.texcoord[0], { -@sample_offset, -@sample_offset };
TEX s00, s00, texture[0], 2D;
ADD s02, fragment.texcoord[0], {  @sample_offset, -@sample_offset };
TEX s02, s02, texture[0], 2D;
ADD s20, fragment.texcoord[0], { -@sample_offset,  @sample_offset };
TEX s20, s20, texture[0], 2D;
ADD s22, fragment.texcoord[0], {  @sample_offset,  @sample_offset };
TEX s22, s22, texture[0], 2D;

TEMP t, u;

ADD t, s00, s20;
SUB t, t, s02;
SUB t, t, s22;
MUL t, t, t;

ADD u, s00, s02;
SUB u, u, s20;
SUB u, u, s22;
MUL u, u, u;

ADD t, t, u;

ADD result.color, sample, t;
#MOV result.color, t;
END
]
