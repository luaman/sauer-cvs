// standard shader definitions

fpopts = [
    @(if (= $shaderprecision 1) [result "OPTION ARB_precision_hint_fastest;"])
    @(if (= $shaderprecision 3) [result "OPTION ARB_precision_hint_nicest;"])
]

vpstart = [
	!!ARBvp1.0
    OPTION ARB_position_invariant;
	ATTRIB opos = vertex.position; 
]

fpstart = [
    !!ARBfp1.0
    @fpopts
]

macro normalize [
	DP3 %1.w, %2, %2;
	RSQ %1.w, %1.w;
	MUL %1.xyz, %1.w, %2;
]

fogcoord = [
    TEMP fogplane;
    MAD fogplane, state.matrix.modelview.row[2], program.env[9].x, program.env[9].yyzw;
    DP4 result.fogcoord, -opos, fogplane;
]

macro rgbafog [
    TEMP fog;
    SUB fog, state.fog.params.z, fragment.fogcoord.x;
    MUL_SAT fog, fog, state.fog.params.w;
    LRP result.color, fog, %1, %2;
]

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader 0 "default" [		
	@vpstart
	MOV result.texcoord[0], vertex.texcoord[0];
	MOV result.color, vertex.color;
	END
] [
    @fpstart
	TEMP diffuse;
	TEX diffuse, fragment.texcoord[0], texture[0], 2D;
	MUL result.color, fragment.color, diffuse;
	END
]

shader 0 "rgbonly" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL result.color.xyz, fragment.color, diffuse;
    MOV result.color.w, fragment.color;
    END
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader 0 "notexture" [		
	@vpstart
	MOV result.color, vertex.color;
	END
] [
    @fpstart
	MOV result.color, fragment.color;
	END
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END 
] [ 
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL result.color, fragment.color, diffuse;
    END
]   

shader 0 "foggednotexture" [
    @vpstart
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    MOV result.color, fragment.color;
    END
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    @vpstart
    END
] [
    @fpstart
    END
]

// some OpenGL implementations don't have consistent depth computation between assembly and GLSL shaders
shader 4 "nocolorglsl" [
    void main() { gl_Position = ftransform(); } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
	shader 0 $arg1 [
		@vpstart
		DP3 result.texcoord[0].x, opos, program.env[0];
		DP3 result.texcoord[0].y, opos, program.env[1];
		DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
		DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];
        @arg2
        @fogcoord
		END
	] [
        @fpstart
		OPTION ARB_fog_linear;
		TEMP diffuse, lm;
		TEX diffuse, fragment.texcoord[0], texture[0], 2D;
		TEX lm,      fragment.texcoord[1], texture[1], 2D;
		@arg3
		MUL diffuse, diffuse, 2;
		@(if (< $numargs 4) [result [MUL result.color, diffuse, lm;]] [result $arg4])
		END
	]
]

worldshader "stdworld" [] []
worldshader "decalworld" [] [
	TEMP decal;
	TEX decal, fragment.texcoord[0], texture[2], 2D;
	LRP diffuse, decal.w, decal, diffuse;
]
setpixelparam 0 1 1 1 // glow color
worldshader "glowworld" [] [] [
    TEMP glow;
    TEX glow, fragment.texcoord[0], texture[2], 2D;
    MUL glow, glow, program.env[10];
    MAD result.color, lm, diffuse, glow;
]
setvertexparam 1 1 // pulse frequency (Hz)
worldshader "pulseworld" [
    TEMP k;
    MUL k, program.env[6], program.env[11].x;
    FRC k, k;
    MAD k, k, 2, -1;
    ABS result.texcoord[2], k;
] [
    TEMP pulse;
    TEX pulse, fragment.texcoord[0], texture[2], 2D;
    LRP diffuse, fragment.texcoord[2], pulse, diffuse;
]
setvertexparam 0 1 1 1 // glow color
setvertexparam 1 1 // pulse frequency (Hz)
setvertexparam 2 0 0 0 // pulse glow color
worldshader "pulseglowworld" [
    TEMP k, col;
    MUL k, program.env[6], program.env[11].x;
    FRC k, k;
    MAD k, k, 2, -1;
    ABS k, k;
    SUB col, program.env[12], program.env[10]; 
    MAD result.texcoord[2], k, col, program.env[10];
] [] [
    TEMP glow;
    TEX glow, fragment.texcoord[0], texture[2], 2D;
    MUL glow, glow, fragment.texcoord[2];
    MAD result.color, lm, diffuse, glow;
]

shader 0 "fogworld" [
    @vpstart
    END
] [
    @fpstart
    MOV result.color, state.fog.color;
    END
]

setpixelparam 0 0.2 0.2 0.2 // reflectivity 
shader 2 "envworld" [
    @vpstart 
    DP3 result.texcoord[0].x, opos, program.env[0];
    DP3 result.texcoord[0].y, opos, program.env[1];
    DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
    DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];

    MAD result.texcoord[3], vertex.color, 2, -1;
    SUB result.texcoord[4], program.env[4], opos;

    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    ATTRIB normal = fragment.texcoord[3];
    ATTRIB camvec = fragment.texcoord[4];
    TEMP rvec;
    DP3 rvec, camvec, normal;
    MUL rvec, rvec, normal; 
    MAD rvec, rvec, 2, -camvec; 
    MOV rvec.y, -rvec;

    TEMP diffuse, lm, reflect;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    TEX lm,      fragment.texcoord[1], texture[1], 2D;
    TEX reflect, rvec.yzxw, texture[2], CUBE;

    MUL diffuse, diffuse, 2;
    MUL diffuse, diffuse, lm;

    LRP result.color, program.env[10], reflect, diffuse;

    END
]
setpixelparam 0 0.2 0.2 0.2 // reflectivity 
shader 2 "envworldfast" [
    @vpstart
    DP3 result.texcoord[0].x, opos, program.env[0];
    DP3 result.texcoord[0].y, opos, program.env[1];
    DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
    DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];

    TEMP camvec, normal, rvec;
    MAD normal, vertex.color, 2, -1;
    SUB camvec, program.env[4], opos;
    DP3 rvec, camvec, normal;
    MUL rvec, rvec, normal; 
    MAD rvec, rvec, 2, -camvec; 
    MOV rvec.y, -rvec;
    MOV result.texcoord[2], rvec.yzxw;

    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse, lm, reflect;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    TEX lm,      fragment.texcoord[1], texture[1], 2D;
    TEX reflect, fragment.texcoord[2], texture[2], CUBE;

    MUL diffuse, diffuse, 2;
    MUL diffuse, diffuse, lm;

    LRP result.color, program.env[10], reflect, diffuse;

    END
]
altshader envworld stdworld
fastshader envworld envworldfast 2
fastshader envworld stdworld 1

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (10 steps)
//    g -> glow
//    G -> pulse glow

btopt = [ result (>= (strstr $bumptype $arg1) 0) ]

bumpshader = [
    bumptype = $arg2
    normtex = (if (btopt "e") [result "texture[4]"] [result "texture[3]"])
    glowtex = (if (btopt "e") [result "texture[5]"] [result "texture[4]"])
    if (btopt "G") [
        setvertexparam 0 1 1 1 // glow color
        setvertexparam 4 1     // pulse frequency (Hz)
        setvertexparam 5 0 0 0 // pulse glow color
    ] [if (btopt "g") [
        setpixelparam 0 1 1 1  // glow color
    ]]
    if (btopt "S") [
        setpixelparam 1 6 6 6 // spec map multiplier
    ] [if (btopt "s") [
        setpixelparam 1 1 1 1 // spec multiplier
    ]]
    if (|| (btopt "p") (btopt "P")) [
        setpixelparam 2 0.06 -0.03 // parallax scaling
    ]
    if (btopt "R") [
        setpixelparam 3 1 1 1 // reflectivity map multiplier
    ] [if (btopt "r") [
        setpixelparam 3 0.2 0.2 0.2 // reflectivity 
    ]]
    shader (if (btopt "e") [result 3] [result 1]) $arg1 [
	    @vpstart
	    DP3 result.texcoord[0].x, opos, program.env[0];
	    DP3 result.texcoord[0].y, opos, program.env[1];
        // need to store these in Z/W to keep texcoords < 6, otherwise kills performance on Radeons
	    DP3 @(if (btopt "r") [result "result.texcoord[0].z"] [result "result.texcoord[2].x"]), state.matrix.texture[1].row[0], vertex.texcoord[1];
	    DP3 @(if (btopt "r") [result "result.texcoord[0].w"] [result "result.texcoord[2].y"]), state.matrix.texture[1].row[1], vertex.texcoord[1];
        @fogcoord
    	
        @(if (btopt "o") [result [
    	    TEMP camv, normal, tangent, binormal, x, y;
    	    MAD normal, vertex.color, 2, -1;
	    
    	    // TS gram-schmidt orthonormalization, needed for non-90 degree surfaces (expensive, TS only used for eye vector! can remove if no spec/parallax)
    	    DP3 x, normal, program.env[2];
    	    MUL x, x, normal;
    	    SUB tangent, program.env[2], x;
    	    DP3 x, tangent, program.env[3];
    	    MUL x, x, tangent;
            DP3 y, normal, program.env[3];
            MUL y, y, normal;
            SUB binormal, program.env[3], x;
            SUB binormal, binormal, y;
    	
            @@(if (btopt "t") [result [
	            // trans eye vector into TS
	            SUB camv, program.env[4], opos;
	            DP3 result.texcoord[1].x, camv, tangent;
	            DP3 result.texcoord[1].y, camv, binormal;
	            DP3 result.texcoord[1].z, camv, normal;
            ]])
            @@(if (btopt "r") [result [
                @@(if (btopt "t") [result [
                    MOV result.texcoord[2], camv;
                ]] [result [
                    SUB result.texcoord[2], program.env[4], opos;
                ]])

                // calculate tangent -> world transform
                MOV result.texcoord[3].x, tangent.x;
                MOV result.texcoord[3].y, binormal.x;
                MOV result.texcoord[3].z, normal.x;

                MOV result.texcoord[4].x, tangent.y;
                MOV result.texcoord[4].y, binormal.y;
                MOV result.texcoord[4].z, normal.y;

                MOV result.texcoord[5].x, tangent.z;
                MOV result.texcoord[5].y, binormal.z;
                MOV result.texcoord[5].z, normal.z;
            ]])
	    ]])

        @(if (btopt "G") [result [
            TEMP pulse, pulsecol;
            MUL pulse, program.env[6], program.env[14].x;
            FRC pulse, pulse;
            MAD pulse, pulse, 2, -1;
            ABS pulse, pulse;
            SUB pulsecol, program.env[15], program.env[10]; 
            MAD result.texcoord[6], pulse, pulsecol, program.env[10];
        ]])

	    END
    ] [
        @fpstart
	    OPTION ARB_fog_linear;
        ATTRIB @(if (|| (btopt "p") (btopt "P")) [result "htc"] [result "dtc"]) = fragment.texcoord[0];
        ATTRIB lmtc = @(if (btopt "r") [result "fragment.texcoord[0]"] [result "fragment.texcoord[2]"]);
        @(if (btopt "t") [result [ATTRIB cam = fragment.texcoord[1];]])
        @(if (btopt "r") [result [ATTRIB camw = fragment.texcoord[2];]]) 
	    TEMP diffuse, lmc, lmlv, bump, camvts, he, height, light, normal;

	    TEX lmc,  @(if (btopt "r") [result "lmtc.zwzw"] [result "lmtc"]), texture[1], 2D;
	    TEX lmlv, @(if (btopt "r") [result "lmtc.zwzw"] [result "lmtc"]), texture[2], 2D;
	    MAD lmlv, lmlv, 2, -1;	
    
        @(if (btopt "t") [result [@(normalize camvts cam)]])
        @(if (btopt "s") [result [
	        ADD he, camvts, lmlv;
	        @(normalize he he) 
        ]])

        @(if (btopt "p") [result [
            TEX height, htc, @@normtex, 2D;
            MAD height.w, height.w, program.env[12].x, program.env[12].y;    
            TEMP dtc;
            MAD dtc, height.w, camvts, htc;
        ]])

        @(if (btopt "P") [result [
            PARAM step = -0.142857142857143; // 1 / 7
            TEMP duv, dtc, cc;
            RCP duv, camvts.z;
            MUL duv, duv, camvts;
            MUL duv, duv, step;
            MUL duv, duv, program.env[12].x;

            MOV height, 1.0;
            MAD dtc, duv, program.env[12].y, htc;
            TEX bump, dtc, @@normtex, 2D; 

            @@(loopconcat i 7 [concatword [
                SLT cc, bump.w, height;
                MAD height, step, cc, height;
                MAD dtc, duv, cc, dtc;
                TEX bump, dtc, @@normtex, 2D;
            ]])
        ]])

	    TEX diffuse, dtc, texture[0], 2D;
	    @(if (! (btopt "P")) [result [TEX bump, dtc, @normtex, 2D;]])
	    MAD bump.xyz, bump, 2, -1;
   
        @(if (btopt "r") [result [
            DP3 normal.x, bump, fragment.texcoord[3];
            DP3 normal.y, bump, fragment.texcoord[4];
            DP3 normal.z, bump, fragment.texcoord[5];
        ]])	
        @(if (btopt "s") [result [
            PARAM specfactor = 32;

	        DP3_SAT he, he, bump;
	        POW he, he.x, specfactor.x;
            MUL he, he, program.env[11];
	    ]])
        @(if (btopt "S") [result [MUL he, he, diffuse.w;]])

	    DP3_SAT bump, bump, lmlv;
        MUL light, lmc, bump;
        MAX light, light, program.env[5];

        @(if (btopt "s") [result [MAD diffuse.xyz, diffuse, 2, he;]] [result [MUL diffuse.xyz, diffuse, 2;]])
        @(if (btopt "g") [result [
            TEMP glow;
            TEX glow, dtc, @@glowtex, 2D;
            MUL glow, glow, @@(if (btopt "G") [result "fragment.texcoord[6]"] [result "program.env[10]"]);
            @@(if (! (btopt "r")) [result [MAD result.color, diffuse, light, glow;]])
        ]])
        @(if (btopt "r") [result [
            TEMP rvec, reflect;
            DP3 rvec, camw, normal;
            MUL rvec, rvec, normal; 
            MAD rvec, rvec, 2, -camw; 
            MOV rvec.y, -rvec;

            TEX reflect, rvec.yzxw, texture[3], CUBE;
            @@(if (btopt "R") [result [
                TEMP rmod;
                MUL rmod, diffuse.w, program.env[13];
            ]] [result [
                PARAM rmod = program.env[13];
            ]])
            MUL diffuse, diffuse, light;
            @@(if (btopt "g") [result [
                LRP diffuse, rmod, reflect, diffuse;
                ADD result.color, diffuse, glow;
            ]] [result [
                LRP result.color, rmod, reflect, diffuse;
            ]])
        ]])   
        @(if (! (|| (btopt "g") (btopt "r"))) [result [
            MUL result.color, light, diffuse;
        ]])

	    END
    ]
]

bumpshader "bumpworld"
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2

bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2

bumpshader "bumpspecglowworld" "otsg"
bumpshader "bumpspecmapglowworld" "otsSg"
bumpshader "bumpglowworld" "g"
fastshader bumpspecmapglowworld bumpglowworld 2

bumpshader "bumpspecpulseglowworld" "otsgG"
bumpshader "bumpspecmappulseglowworld" "otsSgG"
bumpshader "bumppulseglowworld" "gG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2

bumpshader "bumpspecparallaxworld" "pots"
bumpshader "bumpspecmapparallaxworld" "potsS"
bumpshader "bumpparallaxworld" "pot"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1

bumpshader "bumpspecparallaxglowworld" "potsg"
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1

bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1

bumpshader "bumpenvworld" "eor"
bumpshader "bumpenvworldalt" "e"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworld" "eorg"
bumpshader "bumpenvglowworldalt" "eg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworld" "eorgG"
bumpshader "bumpenvpulseglowworldalt" "egG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworld" "epotr"
bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworld" "epotrg"
bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

modelshader = [
	shader 0 $arg1 [
		@vpstart
		ATTRIB onormal = vertex.normal; 
		PARAM ocampos = program.env[1];
		PARAM lightdir = program.env[0];
		MOV result.texcoord[0], vertex.texcoord[0];
		MOV result.texcoord[1], onormal;
		MOV result.color, vertex.color;
        TEMP camvec;
		SUB camvec, ocampos, opos;
		@(normalize camvec camvec)
        MOV result.texcoord[2], lightdir;
		ADD result.texcoord[3], lightdir, camvec;

        @arg2

        @fogcoord
		END
	] [
        @fpstart
		OPTION ARB_fog_linear;
        ATTRIB dtc = fragment.texcoord[0];
		ATTRIB normal = fragment.texcoord[1];
		ATTRIB lightdir = fragment.texcoord[2];
		ATTRIB halfangle = fragment.texcoord[3];
        PARAM specfactor = 128;
		PARAM specintensity = program.env[2];
		PARAM ambient = program.env[3];
        PARAM glowscale = program.env[4];
		TEMP diffuse, rnormal, rhalfangle, light, spec;

		@(normalize rhalfangle halfangle)
		@(normalize rnormal normal)

		DP3_SAT spec, rhalfangle, rnormal;
		POW spec, spec.x, specfactor.x;
		MUL spec, spec, specintensity;

		DP3_SAT light, rnormal, lightdir;
		MUL light, light, 1.5;
		MAX light, light, ambient;

		TEX diffuse, dtc, texture[0], 2D;

        @arg3

		END
	]
]

modelshader "stdmodel" [] [
    MAD light, light, diffuse, spec;
    MUL result.color, light, fragment.color; 
]
modelshader "masksmodel" [] [ // specmap & glowmap version
	TEMP masks;
	TEX masks, fragment.texcoord[0], texture[1], 2D;
	MUL spec, spec, masks.r;				// specmap in red channel

    MAD light, light, diffuse, spec;
    MUL light, light, fragment.color;

    TEMP glow;
    MUL glow, diffuse, glowscale;           // glowmap in green channel
    LRP result.color, masks.g, glow, light;
]
modelshader "envmapmodel" [ // specmap, glowmap & envmap version
    TEMP rvec, invfresnel;
    DP3 invfresnel, camvec, onormal;
    MUL rvec, invfresnel, onormal; 
    MAD rvec, rvec, 2, -camvec;
    DP3 result.texcoord[4].x, -state.matrix.texture.row[1], rvec;
    DP3 result.texcoord[4].y, state.matrix.texture.row[2], rvec;
    DP3 result.texcoord[4].z, state.matrix.texture.row[0], rvec;
    MAX invfresnel, invfresnel, 0;
    MAD result.texcoord[4].w, program.env[5].x, invfresnel, program.env[5].y;
] [
    TEMP masks, color;
    TEX masks, fragment.texcoord[0], texture[1], 2D;
    MUL spec, spec, masks.r;                // specmap in red channel

    MUL light, light, diffuse;
    ADD light, light, spec;
    MUL light, light, fragment.color;

    TEMP glow;
    MUL glow, diffuse, glowscale;           // glowmap in green channel
    LRP light, masks.g, glow, light;
    
    TEMP reflect;
    TEX reflect, fragment.texcoord[4], texture[2], CUBE;
    MUL masks.b, masks.b, fragment.texcoord[4].w; // envmap mask in blue channel
    LRP result.color, masks.b, reflect, light;
]
altshader envmapmodel masksmodel

////////////////////////////////////////////////
//
// gourad lighting model shader: cheaper, non-specular version for vegetation etc. gets used when spec==0
//
////////////////////////////////////////////////

alias nospecmodelshader [
    shader 0 $arg1 [
	    @vpstart
        ATTRIB onormal = vertex.normal; 
	    PARAM ocampos = program.env[1];
	    PARAM lightdir = program.env[0];
	    PARAM ambient = program.env[3];
	    TEMP light;

	    MOV result.texcoord[0], vertex.texcoord[0];

	    DP3 light, onormal, lightdir;
	    MUL light, light, 1.5;
	    MAX light, light, ambient;
	    MUL result.texcoord[1], light, vertex.color;

        @fogcoord
	    END
    ] [
        @fpstart
	    OPTION ARB_fog_linear;
	    ATTRIB light = fragment.texcoord[1];
	    TEMP diffuse;

	    TEX diffuse, fragment.texcoord[0], texture[0], 2D;

        @arg2

	    END
    ]
]

nospecmodelshader nospecmodel [MUL result.color, light, diffuse;]
nospecmodelshader masksnospecmodel [
    TEMP color, glow, masks;
    MUL color, diffuse, light;
    MUL glow, diffuse, program.env[4];
    TEX masks, fragment.texcoord[0], texture[1], 2D;
    LRP result.color, masks.g, glow, color;
]   

fastshader stdmodel nospecmodel 1
fastshader masksmodel masksnospecmodel 1
fastshader envmapmodel masksnospecmodel 1

// model shadows

shader 0 "dynshadow" [
    @vpstart
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    MOV result.color, fragment.color;
    END
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [
	!!ARBvp1.0
	MOV result.position, vertex.position;   // woohoo, no mvp :) 
	MOV result.texcoord[0], vertex.texcoord[0];
]

fsps = [
    @fpstart
	TEMP sample;
	TEX sample, fragment.texcoord[0], texture[0], RECT;
]

setup4corners = [
	ADD result.texcoord[1], vertex.texcoord[0], { -1, -1, 0, 0 };		
	ADD result.texcoord[2], vertex.texcoord[0], {  1, -1, 0, 0 };		
	ADD result.texcoord[3], vertex.texcoord[0], { -1,  1, 0, 0 };		
	ADD result.texcoord[4], vertex.texcoord[0], {  1,  1, 0, 0 };		
]

sample4corners = [
	TEMP s00, s02, s20, s22;
	TEX s00, fragment.texcoord[1], texture[0], RECT;
	TEX s02, fragment.texcoord[2], texture[0], RECT;
	TEX s20, fragment.texcoord[3], texture[0], RECT;
	TEX s22, fragment.texcoord[4], texture[0], RECT;
]

// some simple ones that just do an effect on the RGB value...

shader 0 "invert" [ @fsvs END ] [ @fsps SUB result.color, 1, sample;   END ]
shader 0 "gbr"    [ @fsvs END ] [ @fsps MOV result.color, sample.yzxw; END ]
shader 0 "bw"     [ @fsvs END ] [ @fsps DP3 result.color, sample, 0.333; END ]

// sobel

shader 0 "sobel"  [ @fsvs @setup4corners END ] [
	@fsps
	@sample4corners

	TEMP t, u;

	ADD t, s00, s20;
	SUB t, t, s02;
	SUB t, t, s22;
	MUL t, t, t;

	ADD u, s00, s02;
	SUB u, u, s20;
	SUB u, u, s22;
	MUL u, u, u;

	ADD t, t, u;

	ADD result.color, sample, t;
	END
]


// bloom-ish

shader 0 "bloom_scale"   [ @fsvs @setup4corners END ] [
	@fsps
	@sample4corners

	TEMP t;
	ADD t, s02, s00;
	ADD t, t, s22;
	ADD t, t, s20;
	ADD t, t, sample;
	MUL result.color, t, 0.2; 
	END
]

shader 0 "bloom"   [ 
    @fsvs
    TEMP tc;
    MOV tc, vertex.texcoord[0];
    @(loopconcat i 6 [concat "MUL tc, tc, 0.5; MOV result.texcoord[" (+ $i 1) "], tc;"])
    END
] [
	@fsps
	TEMP scaled, t;
    @(loopconcat i 6 [
        format [ 
            TEX scaled, fragment.texcoord[%1], texture[%1], RECT;
            DP3 t, scaled, { 0.3, 0.5, 0.2, 1 };    // luminosity filter
            MUL t, t, t;
            MUL t, t, scaled;
            MAD sample, t, program.env[0].x, sample;
        ] (+ $i 1)
      ]
    )
	MOV result.color, sample;
	END
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and blends the edge color
// and modulates the texture
shader 0 "explosion" [
    !!ARBvp1.0
    ATTRIB opos = vertex.position; 
    OUTPUT spos = result.position; 
    TEMP wobble;

    DP3 wobble, opos, program.env[0]; // generate wobble offset based off vertex normal and sphere center
    MAD wobble, program.env[1].xxxx, 1.5, wobble; // wobble frequency
    FRC wobble, wobble; // 0..1
    SUB wobble, wobble, 0.5; // -0.5..0.5
    ABS wobble, wobble; // now oscillates up and down between 0..0.5
    MAD wobble, wobble, 0.5, -0.125; // wobble amplitude
    
    MOV wobble.w, 0;
    MAD wobble, wobble, opos, opos;

    DP4 spos.x, state.matrix.mvp.row[0], wobble; 
    DP4 spos.y, state.matrix.mvp.row[1], wobble; 
    DP4 spos.z, state.matrix.mvp.row[2], wobble; 
    DP4 spos.w, state.matrix.mvp.row[3], wobble;

    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;   

    TEMP pos, norm, blend;
    DP4 pos.x, state.matrix.modelview[0].row[0], opos; 
    DP4 pos.y, state.matrix.modelview[0].row[1], opos; 
    DP4 pos.z, state.matrix.modelview[0].row[2], opos; 
    @(normalize pos pos)
    
    DP3 norm.x, state.matrix.modelview[0].invtrans.row[0], wobble; 
    DP3 norm.y, state.matrix.modelview[0].invtrans.row[1], wobble; 
    DP3 norm.z, state.matrix.modelview[0].invtrans.row[2], wobble; 
    @(normalize norm norm)
   
    XPD result.texcoord[1], norm, pos;
    DP3 blend, pos, norm;
    MUL blend, blend, -2.0;
    MUL result.color.w, blend, vertex.color.w;
    END
] [
    @fpstart
    TEMP dtc, diffuse;
    TEX dtc, fragment.texcoord[1], texture[0], 2D;
    MAD dtc, dtc, 0.1, fragment.texcoord[0];
    TEX diffuse, dtc, texture[0], 2D;
    MUL result.color, fragment.color, diffuse;  
    END
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

alias watershader [
    spec = $arg2
    rgbfog = $arg3
    distort = $arg4
    combine = $arg5
    shader 1 $arg1 [
        @vpstart
        TEMP tc;
        PARAM campos = program.env[0];
        PARAM seconds = program.env[1];
        @(if $spec [result "PARAM lightpos = program.env[2];"])

        DP4 result.texcoord[0].x, state.matrix.texture.row[0], opos;
        DP4 result.texcoord[0].y, state.matrix.texture.row[1], opos;
        DP4 result.texcoord[0].z, state.matrix.texture.row[2], opos;
        DP4 result.texcoord[0].w, state.matrix.texture.row[3], opos;
        MUL tc, vertex.texcoord[0], 0.1;
        MAD result.texcoord[1], seconds, 0.04, tc;
        MAD result.texcoord[2], seconds, -0.02, tc;
        SUB result.texcoord[3], campos, opos;
        @(if $spec [result "SUB result.texcoord[4], lightpos, opos;"])
 
        MOV result.color, vertex.color;

        @fogcoord

        END
    ] [
        @fpstart
        @(if $rgbfog [result "OPTION ARB_fog_linear;"])
        TEMP he, light, cam, bump, invfresnel, temp, dudv;

        ATTRIB projtc = fragment.texcoord[0];
        ATTRIB tc1 = fragment.texcoord[1];
        ATTRIB tc2 = fragment.texcoord[2];
        ATTRIB camts = fragment.texcoord[3];
        @(if $spec [result "ATTRIB lightts = fragment.texcoord[4];"])

        @(normalize cam camts)
        @(if $spec [result [
            @(normalize light lightts)
            ADD he, cam, light;
            @(normalize he he)
        ]])

        TEX dudv, tc1, texture[2], 2D;
        MAD dudv.xy, dudv, 2, -1;

        @distort

        @(if $spec [result [
            PARAM specfactor = 96;

            DP3_SAT he, he, bump;
            POW he, he.x, specfactor.w;
    
            MUL light, program.env[4], light.w;
            RCP_SAT light, light.x;
            MAD light, light, -program.env[3], program.env[3];
        ]])

        @combine

        END
    ]
]

watershader "water" 1 0 [
    MAD temp, dudv, 0.025, tc2; 
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    TEMP diffuse;
    MUL temp, fragment.color, program.env[5].x;
    MUL diffuse, temp, 0.6;
    DP3_SAT invfresnel, cam, bump;
    LRP temp, invfresnel, temp, diffuse;

    TEMP col;
    MAD col.rgb, he, light, temp; 
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
watershader "waterfast" 0 0 [
    MAD temp, dudv, 0.025, tc2; 
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [    
    TEMP diffuse;
    MUL temp, fragment.color, program.env[5].x;
    MUL diffuse, temp, 0.6;
    DP3_SAT invfresnel, cam, bump;

    TEMP col;
    LRP col.rgb, invfresnel, temp, diffuse;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
fastshader water waterfast 1

alias reflectivity [MAD invfresnel, invfresnel, 0.5, 0.5;]

watershader "waterreflect" 1 0 [
    TEMP reflect;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    MUL temp, fragment.color, program.env[5].x;
    LRP temp, invfresnel, temp, reflect;

    TEMP col;
    MAD col.rgb, he, light, temp;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
watershader "waterreflectfast" 0 0 [
    TEMP reflect;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    MUL temp, fragment.color, program.env[5].x;

    TEMP col;
    LRP col.rgb, invfresnel, temp, reflect;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
fastshader waterreflect waterreflectfast 2

watershader "waterrefract" 1 1 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xyz, projtc, temp.wwww; 
    MAD temp.xy, dudv, 0.01, temp;

    TEX reflect, temp, texture[0], 2D;
    TEX refract, temp, texture[3], 2D;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP temp, invfresnel, refract, reflect;
    MAD result.color, he, light, temp;
]
watershader "waterrefractfast" 0 1 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;
    TXP refract, temp, texture[3], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP result.color, invfresnel, refract, reflect;
]
fastshader waterrefract waterrefractfast 2

alias causticshader [
    shader 0 $arg1 [
        @vpstart
        DP3 result.texcoord[0].x, opos, state.texgen.object.s;
        DP3 result.texcoord[0].y, opos, state.texgen.object.t;
        @fogcoord
        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        @arg2
        END
    ]
]
causticshader caustic [
    TEMP caustic, caustic2;
    TEX caustic, fragment.texcoord[0], texture[0], 2D;
    TEX caustic2, fragment.texcoord[0], texture[1], 2D;
    LRP result.color, program.env[0], caustic2, caustic;
]
causticshader causticfast [TEX result.color, fragment.texcoord[0], texture[0], 2D;]
fastshader caustic causticfast 2

shader 0 "glass" [
    @vpstart
    PARAM campos = program.env[0];
    ATTRIB normal = vertex.normal;
    TEMP camvec, rvec, tmp;
    SUB camvec, campos, opos;
    MOV result.texcoord[0], camvec;
    DP3 tmp, camvec, normal;
    MUL tmp, tmp, normal;
    MAD rvec, tmp, 2, -camvec; 
    MOV rvec.y, -rvec;
    MOV result.texcoord[1], rvec.yzxw;
    MOV result.texcoord[2], normal;
    MOV result.color, vertex.color;
    @fogcoord
    END 
] [ 
    @fpstart
    ATTRIB camvec = fragment.texcoord[0];
    ATTRIB rvec = fragment.texcoord[1];
    ATTRIB normal = fragment.texcoord[2];

    TEMP reflect;
    TEX reflect, rvec, texture[0], CUBE;
    
    TEMP invfresnel;
    @(normalize invfresnel camvec)
    DP3 invfresnel, invfresnel, normal;
    MAX invfresnel, invfresnel, 0.70;

    TEMP col;
    MUL col, fragment.color, 0.05;
    LRP col.rgb, invfresnel, col, reflect;
    MUL col.a, invfresnel, 0.95;
 
    @(rgbafog col "{0, 0, 0, 1}")
    END
]
shader 0 "glassfast" [
    @vpstart
    PARAM campos = program.env[0];
    ATTRIB normal = vertex.normal;
    TEMP camvec, rvec, tmp;
    SUB camvec, campos, opos;
    DP3 tmp, camvec, normal;
    MUL tmp, tmp, normal;
    MAD rvec, tmp, 2, -camvec; 
    MOV rvec.y, -rvec;
    MOV result.texcoord[0], rvec.yzxw;
    MOV result.color, vertex.color;
    @fogcoord
    END 
] [ 
    @fpstart
    ATTRIB rvec = fragment.texcoord[0];

    TEMP reflect;
    TEX reflect, rvec, texture[0], CUBE;
    
    PARAM invfresnel = 0.75;
    TEMP col;
    MUL col, fragment.color, 0.05;
    LRP result.color.xyz, invfresnel, col, reflect;
    MUL result.color.w, invfresnel, 0.95;

    @(rgbafog col "{0, 0, 0, 1}")
    END
]
fastshader glass glassfast 2

shader 0 "grass" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL diffuse.xyz, diffuse, 2;
    MUL result.color, fragment.color, diffuse;
    END
]

setuniformparam bumpscale 0.06 -0.03
shader 5 glsltest [
    uniform vec4 texgenS, texgenT, camera, orienttangent, orientbinormal, fogparams;
    varying vec3 camvts;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].st = vec2(dot(gl_Vertex.xyz, texgenS.xyz), dot(gl_Vertex.xyz, texgenT.xyz));
        gl_TexCoord[1].st = vec4(gl_TextureMatrix[1] * gl_MultiTexCoord1).st;
        vec4 fogplane = vec4(gl_ModelViewMatrix[0].z, gl_ModelViewMatrix[1].z, gl_ModelViewMatrix[2].z, gl_ModelViewMatrix[3].z) * fogparams.x + fogparams.yyzw;
        gl_FogFragCoord = dot(-gl_Vertex, fogplane);

        vec3 x, y, tangent, binormal, camv;
        vec3 normal = gl_Color.xyz * 2.0 - 1.0;

        x = dot(normal, orienttangent.xyz) * normal;
        tangent = orienttangent.xyz - x;
        x = dot(tangent, orientbinormal.xyz) * tangent;   
        y = dot(normal, orientbinormal.xyz) * normal;
        binormal = (orientbinormal.xyz - x) - y;
               
        camv = camera.xyz - gl_Vertex.xyz;                
        camvts = vec3(dot(camv, tangent), dot(camv, binormal), dot(camv, normal));
        
    }
] [
    varying vec3 camvts;
    uniform vec4 ambient, bumpscale;
    uniform sampler2D diffusemap, lmcolor, lmdir, normalmap;
    void main(void)
    {
        vec4 lmc = texture2D(lmcolor, gl_TexCoord[1].st);
        vec3 lmlv = texture2D(lmdir, gl_TexCoord[1].st).xyz * 2.0 - 1.0;
        vec3 camn = normalize(camvts);

        float steps = mix(5.0, 20.0, camn.z);
        float dh = 1.0 / steps;
        vec2 duv = -camn.xy*bumpscale.x / (camn.z*steps);
        float height = 1.0;

        vec2 dtc = gl_TexCoord[0].st + duv*bumpscale.y;
        vec4 bump = texture2D(normalmap, dtc);

        while(bump.w < height)
        {
            height -= dh;
            dtc += duv;
            bump = texture2D(normalmap, dtc);
        }

        vec4 diffuse = texture2D(diffusemap, dtc) * 2.0;
        vec3 normal = bump.xyz * 2.0 - 1.0;
        
        float intensity = dot(normal, lmlv);
        if(intensity > 0.0)
        {
            steps = mix(10.0, 20.0, lmlv.z);
            dh = 1.0 / steps;
            duv = lmlv.xy*bumpscale.x / (lmlv.z*steps);

            height = bump.w + dh*0.1;
            while(bump.w < height && height < 1.0)
            {
                height += dh;
                dtc += duv;
                bump = texture2D(normalmap, dtc);
            }

            if(bump.w >= height) intensity = 0.0; 
        }

        vec4 light = max(lmc * clamp(intensity, 0.0, 1.0), ambient);
        gl_FragColor = diffuse * light;
        float fog = (gl_Fog.end - gl_FogFragCoord) * gl_Fog.scale;
        gl_FragColor.rgb = mix(vec3(gl_Fog.color), gl_FragColor.rgb, clamp(fog, 0.0, 1.0));
    }
]

