<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Sauerbraten Mapping Command Reference</title>
		<link href="style.css" type="text/css" rel="stylesheet">
	</head>
	<body>
		<div>Editing Related Console Commands</div>
		<pre>edittoggle</pre>
		Switches between map edit mode and normal (default key = e). In map edit mode 
		you can select bits of the map by clicking or dragging your crosshair on the 
		cubes (using the "attack" command, normally MOUSE1), then use the commands 
		below to modify the selection. While in edit mode, physics &amp; collision 
		don't apply (noclip), and key repeat is ON.
		<pre>editface D N</pre>
		This is the main editing command. D is the direction of the action, -1 for 
		towards you, 1 for away from you. N=0 to push all corners in the white box. N=1 
		create or destroy cubes. N=2 push or pull a corner you are pointing at.
		<pre>editheight D</pre>
		Similar to editface N=2, but pushes all four corners surronding the pointed-at 
		vertex.
		<pre>edittex D</pre>
		Changes the texture on current selection by browsing through a list of textures 
		directly shown on the cubes. D is the direction you want to cycle the textures 
		in (1 = forwards, -1 = backwards). By default bound to holding F and using the 
		mouse wheel.
		<br>
		<br>
		The way this works is slightly strange at first, but allows for very fast 
		texture assignment. All textures are in a list. and each time a texture is 
		used, it is moved to the top of the list. So after a bit of editing, all your 
		most frequently used textures will come first, and the most recently used 
		texture is set immediately when you press the forward key for the type. These 
		lists are saved with the map.
		<pre>gridpower N</pre>
		Changes the size of the grid.
		<pre>reorient</pre>
		Change the side the white box is on to be the same as where you are currently 
		pointing.
		<pre>flip</pre>
		Flip (mirror) the selected cubes front to back relative to the side of the white box.
		<pre>rotate D</pre>
		Rotates the selection 90 degrees around the side of the white box. 
		Automatically squares the selection if it isn't already.
		<pre>undo</pre>
		Multi-level undo of any of the changes caused by the above operations (default 
		key = z).
		<pre>undomegs N</pre>
		Sets the number of megabytes used for the undo buffer (default 1, max 10). 
		Undo's work for any size areas, so the amount of undo steps per megabyte is 
		more for small areas than for big ones.
		<pre>copy
paste</pre>
		Copy copies the current selection into a buffer. For pasting, if the current 
		selection is not the same size as the copy, the corner of the red reference box 
		will be used as the origin. If the current gridsize is changed from the copy, 
		the pasted copy will be stretched by the same factor.
		<pre>newent type    value1 value2 value3 value4</pre>
		Adds a new entity where (x,y) is determined by the current selection (the red 
		dot corner) and z by the camera height, of said type. Type is a string giving 
		the type of entity, such as "light", and may optionally take values (depending 
		on the entity). The types are defines below in the <a href="#entitytypes">Entity 
			Types</a> section.
		<pre>delent</pre>
		deletes the entity closest to the player
		<pre>dropent</pre>
		Positions the closest entity according to the entdrop variable.
		<pre>entdrop N</pre>
		variable controlling where entities created with "newent" will be placed.<br>
		N=0 place entities at your current eye position.<br>
		N=1 drop entities to the floor beneath you. Lights, however, will be placed at 
		your current eye position as for N=0.<br>
		N=2 place entities at the center of the currently selected cube face. If a 
		corner is selected, the entity will be placed at the corner vertex.<br>
		N=3 behaves as with N=2, except all entities, including lights, will then 
		bedropped from that position to whatever floor lies beneath. This mode is 
		useful for placing objects on selected floors. Lights are also dropped to the 
		floor, unlike for N=1.
		<pre>entproperty P A</pre>
		Changes property P (0..3) of the closest entity by amount A. For example 
		"entproperty 0 2" when executed near a lightsource would increase its radius by 
		2.
		<pre>clearents type</pre>
		Deletes all entities of said type.
		<pre>editmat</pre>
		Changes the type of material left behind when a cube is deleted. Currently the 
		following types of materials are supported:
		<ul>
			<li>
			air: the default material, has no effect.
			<li>
			water: acts as you would expect. Only renders from the top, so treat it like 
			real water and keep all 4 sides contained.
			<li>
			clip: an invisible wall that blocks players movement but not bullets. Is 
			ideally used to keep players "in bounds" in a map. Can be used sparingly to 
			smooth out the flow around decoration.
			<li>
			noclip: cubes are always treated as empty in physics.
			<li>
				glass: a clip like material with a blended surface.</li>
		</ul>
        <pre>watercolour R G B</pre>
        Changes the blended color of all water to RGB. This may be used to simulate various
        lighting conditions for water.
		<pre>selextend</pre>
		Extend current selection to include the cursor.
		<pre>map name</pre>
		Loads up map "name" in the gamemode set previously by "mode". A map given as 
		"blah" refers to "packages/base/blah.cgz", "mypackage/blah" refers to 
		"packages/mypackage/blah.cgz". The menu has a set of maps that can be loaded. 
		See also map in the gameplay docs.
		<br>
		<br>
		At every map load, "data/default_map_settings.cfg" is loaded which sets up all 
		texture definitions etc. Everything defined in there can be overridden per 
		package or per map by creating a "package.cfg" or "mapname.cfg" which contains 
		whatever you want to do differently from the default. It can also set up 
		triggers scripts per map etc.
		<br>
		<br>
		When the map finishes it will load the next map when one is defined, otherwise 
		reloads the current map. You can define what map follows a particular map by 
		making an alias like (in the map script): <code>alias nextmap_blah1 blah2</code>
		(loads "blah2" after "blah1").
		<pre>savemap name</pre>
		Saves the current map, using the same naming scheme as "map". makes a versioned 
		backup (mapname_N.BAK) if a map by that name already exists, so you can never 
		lose a map. If you leave out the "name" argument, it is saved under the current 
		map name.
		<br>
		<br>
		Where you store a map depends on the complexity of what you are creating: if 
		its a single map (maybe with its own .cfg) then the "base" package is the best 
		place. If its multiple maps or a map with new media (textures etc.) its better 
		to store it in its own package (a directory under "packages"), which makes 
		distributing it less messy.
		<pre>newmap size</pre>
		Creates a new map of size^2 cubes (on the smallest grid size). 10 is a small 
		map, 13 is a large map but it goes up to 16. Use <i>newmap -1</i> to double the 
		dimensions of the current map.
		<pre>mapmsg "Title by Author"</pre>
		sets the map msg, which will be displayed when the map loads. Either use the 
		above format, or simply "by Author" if the map has no particular title (always 
		displayed after the map load msg).
		<pre>recalc</pre>
		Recalculates scene geometry. Shouldn't be needed under normal curcumstances.
		<pre>texturereset</pre>
		Sets the texture slot to 0 for the subsequent "texture" commands.
		<pre>texture subnum filename flags</pre>
		Binds the texture indicated in filename to the current texture slot, then 
		increments the slot number. This is for use in texture.cfg files only. subnum 
		allows secondary textures to be specified for a single texture slot, for use in 
		shaders and other features (unused for now, should be set to 0 to indicate 
		primary texture). Flags allow you to specify preprocessing on the image, 
		currently only rotation (0 = none, 1 = 90 CW, 2 = 180, 3 = 270 CW).
		<pre>trigger N T</pre>
		Triggers trigger N of type T, as if the player had picked up the equivalent 
		"trigger" entity (see below).
		<pre>music name</pre>
		Plays song "name" (with "packages" as base dir). This command is best used from 
		map cfg files or triggers.
		<pre>N = registersound name</pre>
		Registers sound "name" with cube (see for example data/sounds.cfg). This 
		command returns the sound number N, which is assigned from 0 onwards, and which 
		can be used with "sound" command below. if the sound was already registered, 
		its existing index is returned. registersound does not actually load the sound, 
		this is done on first play.
		<pre>sound N</pre>
		Plays sound N, see data/sounds.cfg for default sounds, and use registersound to 
		register your own. for example, <code>sound 0</code> and <code>sound (registersound 
			"aard/jump")</code>both play the standard jump sound.
		<pre>mapmodel R H Z S N</pre>
		<P>
			registers a mapmodel that can be placed in maps using <code><font size="2">newent 
					mapmodel</font></code> (see newent). N is the name, R is the square 
			radius, H the height, Z the initial Z-offset above ground, and S the snap value 
			in 16ths of a cube unit (0 meaning no snap). All of these values are used for 
			collision as well as rendering. Specifying a snap can be useful for 
			architectural mapmodels, as the md2 format doesn't provide exact vertex 
			coordinates. Example: <code><font size="2">mapmodel 4 2 4 2</font></code> this 
			map model is 8x8x2 in size (x,y,z), by default hovers 4 units above ground, and 
			has all coordinates snapped to the nearest even number. See data/models.cfg. 
			Name N is the name of a folder inside packages/models folder, e.g. 
			"hudguns/rifle". Loaded from that folder are: tris.md2 and skin.jpg (and if not 
			available, skin.png, or the same from the parent folder to allow skin sharing).</P>
		<PRE>importcube N</PRE>
		<P>imports a cube map (.cgz) and converts it to sauerbraten's map format. N is the 
			name of the map, without the .cgz. The map file must reside in packages/cube, 
			which is because that folder has a package.cfg that sets the default cube 
			textures. If the cube map in question has a custom texture list, it will have 
			to be adapted manually. Currently converts everything relatively faithfully, 
			except heighfields which are converted as best as possible but not always 
			accurately. Slopes tend to work faultlessly, landscape style stuff is usuable, 
			but curves/arches are problematic, and may have to be redone. All entities are 
			converted though mapmodels may not be present, and light entities are useless 
			because of their 2d nature, so probably the first thing to do after converting 
			a map is /clearents light, and place some new lights. The importcube does not 
			automatically save the map, you still have to do a /savecurrentmap which will 
			create packages/cube/N.ogz. Waterlevel is also not supported, you will have to 
			add water using the new material system.</P>
		<div>Lighting Commands</div>
		<a name="lightingcommands"></a>
		<pre>calclight</pre>
		This calculates all lightmaps. Usually takes only a few seconds, depending on 
		map size and settings. If you "savemap", the lightmap will be stored along with 
		it.
		<pre>patchlight</pre>
		This will calculate lightmaps for any newly created cubes. This will generally 
		be much quicker than doing a "calclight", and so is very useful when editing. 
		However, it will make very inefficient use of lightmap textures, and any new 
		cubes will not properly cast shadows on surfaces that are already lit. It is 
		recommended you do a "calclight" on your map before you publish it with 
		"savemap".
		<pre>fullbright  B</pre>
		This variable controls whether the map will be shown lighting disabled. 
		Fullbright 1 will disable lighting, whereas 0 will enable lighting. (Default = 
		0)
		<pre>lightprecision P</pre>
		Default = 32. This is the most important variable for tweaking the lighting, it 
		determines what the resolution of the lightmap is. As such has a BIG effect on 
		calculation time, video memory usage, and map file size. The default is good 
		for most maps, you may go as low as 16 if you are lighting a really small map 
		and love hard shadows, and for bigger maps you may need to set it to 64 or so 
		to get reasonable memory usage.
		<br>
		<br>
		The number to watch out for is the number of lightmaps generated which are 
		shown on the HUD (and also as output after a calclight). 1 or 2 lightmap 
		textures is very good, over 10 lightmap textures is excessive.
		<br>
		<br>
		The map file size is for 90% determined by the lightmaps, so tweak this value 
		to get an acceptable quality to size ratio. Look at the size of the map files, 
		sometimes a slightly higher lightprecision can halve the size of your .ogz.
		<br>
		<br>
		Every surface matters, even though sauerbraten attempts to compress surfaces 
		with a uniform lightvalue, it is always a good ideas to delete parts of the 
		world that are not part of your map. Lightprecision, lighterror, and lightlod 
		are stored as part of map files.
		<pre>lighterror E</pre>
		There should be little reason to tweak this. If in your map you can see visible 
		polygon boundaries caused by lighting, you can try stepping this down to 6 or 4 
		to improve quality at the expense of lightmap space. If you have an insanely 
		large map and looking for ways to reduce file size, increasing error up to 16 
		may help. (Default = 8)
		<pre>lightlod D</pre>
		Default = 0. This will double the resolution of lightmaps (cut the 
		lightprecision in half) if size of the surface being lit is smaller than 2^D 
		units. This allows large maps to have pockets of detailed lighting without 
		using a high resolution over everything.
		<br>
		<br>
		NOTE: if you feel like using this, test it thoroughly. On medium or small sized 
		detailed maps, this command wastes space, use lightlod 0. Lightlod &gt; 0 is 
		only useful for huge maps
		<pre>aalights X</pre>
		Determines whether to use 4x sampling for every lightmap texel. You should not 
		need to touch this var, unless waiting for calclight really bothers you, you 
		can set it to 0 for a 4x speedup and blockier shadows. Also, for a slight 
		increase in appearance, one may set it to 2 to turn on 8x sampling; however, 
		this takes greatly longer and is enabled by default. (Default = 1)
		<pre>shadows B</pre>
		Determines whether or not objects cast shadows. You should also not need to 
		touch this var. However, it does allow you to see the effectiveness and reach 
		of your lights if turned off. (Default = 1)
		<pre>dumplms</pre>
		Dumps all lightmaps to a set of .bmps. Mostly interesting for developers, but 
		mappers may find it interesting too.
		<div>Entity Types</div>
		<a name="entitytypes"></a>
		<pre>"light" radius brightness
"light" radius r g b</pre>
		If G and B are 0 the R value will be taken as brightness for a white light. A 
		good radius for a small wall light is 64, for a middle sized room 128... for a 
		sun probably more like 1000. Lights with a radius of 0 do not attenuate and may 
		be more appropriate for simulating sunlight or ambient light; however, this 
		comes at the cost of slightly greater map file sizes. See the <a href="#lightingcommands">
			lighting commands</a> for an indepth list of all lighting related commands.
		<pre>"playerstart"</pre>
		Spawn spot, yaw is taken from the current camera yaw.
		<pre>"shells"
"bullets"
"rockets"
"riflerounds"
"health"
"healthboost"
"greenarmour"
"yellowarmour"
"quaddamage"</pre>
		A variety of pickup-able items, see <a href="./game.html">here</a>.
		<pre>"teleport" N
"teledest" N</pre>
		creates a teleport connection, teleports are linked to a teledest with the same 
		N (of which there should be exactly one). N can be 0..255. The teledest uses 
		the current camera yaw.
		<pre>"mapmodel" N</pre>
		A map model, i.e. an object rendered as md2 which you collide against but has 
		no behaviour/movement. N determines which mapmodel you want, currently there is 
		only one, a tree (N = 0). yaw of the model is taken from the current camera 
		yaw.
		<br>
		<br>
		<pre>"monster" N</pre>
		A monster, currently N = 0..4 (see gameplay docs). Monster entities will be 
		spawned when in classic single player mode, and will attack you when you come 
		into view. yaw is taken from the current camera yaw.
		<br>
		<br>
		<pre>"trigger" N T</pre>
		A trigger of type T affecting all cubes with tag N when triggered in game (see 
		"edittag" on how to set tags on cubes). Triggers are rendered as a carrot 
		which, when "eaten", trigger an event (only once). The following trigger types 
		are available:
		<br>
		<br>
		0: doesn't do anything currently
		<br>
		<br>
		1: invisible: same as 0 but without the carrot. Since the trigger radius is 
		fairly small, be sure to place them in tiny hallways and other areas you are 
		sure the player will pass through.
		<br>
		<br>
		2: end of map marker. Ends the map and triggers the intermission. carrot spins 
		wildly.
		<br>
		<br>
		Scripting: each trigger automatically executes the alias "level_trigger_N" 
		where N is the trigger number. This means you can add any scripting you can do 
		through the available commands, by simply putting aliases of this kind in the 
		level .cfg file. For example, to print a message when the user hits trigger 1:
		<br>
		<br>
		alias level_trigger_1 "echo A door opened nearby"
		<br>
		<br>
		Entities are shown in editmode by blue sparklies, and the closest one is 
		indicated on the HUD.
		<div>The HUD</div>
		<a name="hud"></a>On the bottom right of the screen are a bunch of stats. 
		You'll find out what they mean below.
		<ul>
			<li>
			cube: the number of cubes in the current selection. Only the visible (leaf) 
			cubes are counted.
			<li>
			fps: frames per second
			<li>
			ond: number of cubes in the system. This includes parent cubes, copied cubes, 
			and undos.
			<li>
			va: number of vertex arrays used to store vertecies in the map. you probably 
			don't need to use this.
			<li>
			vtr: number of triangles currently being displayed. will be a useful stat when 
			culling is done.
			<li>
			vvt: number of vertecies currently being displayed. again, useful when culling 
			is done.
			<li>
			tri: number of triangles in the entire map
			<li>
			wvt: number of vertecies in the entire map
			<li>
				evt: misc rendering effects. stuff like particles displayed, or text written on 
				screen.</li></ul>
	</body>
</html>
